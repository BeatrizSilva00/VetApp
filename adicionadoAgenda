import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:collection/collection.dart';
import 'package:intl/intl.dart';

// ------------------------------
// Data Models (Modelos de Dados)
// ------------------------------

/// Representa o perfil de um usuário no sistema.
class UserProfile {
  final int id;
  final String name;
  final String email;

  /// Construtor para criar uma nova instância de UserProfile.
  UserProfile({required this.id, required this.name, required this.email});
}

/// Representa um produto disponível na loja.
class Product {
  final int id;
  String name;
  String description;
  double price;
  bool rxOnly;
  String? imageUrl;
  final String category;

  /// Construtor para criar uma nova instância de Produto.
  Product({
    required this.id,
    required this.name,
    required this.description,
    required this.price,
    this.rxOnly = false,
    this.imageUrl,
    required this.category,
  });

  /// Cria uma nova instância de Produto com valores copiados e/ou modificados.
  Product copyWith({
    int? id,
    String? name,
    String? description,
    double? price,
    bool? rxOnly,
    String? imageUrl,
    String? category,
  }) =>
      Product(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        price: price ?? this.price,
        rxOnly: rxOnly ?? this.rxOnly,
        imageUrl: imageUrl ?? this.imageUrl,
        category: category ?? this.category,
      );
}

/// Representa um item individual no carrinho de compras, com um produto e sua quantidade.
class CartItem {
  final Product product;
  final int quantity;

  /// Construtor para criar uma nova instância de CartItem.
  CartItem({required this.product, required this.quantity});

  /// Cria uma nova instância de CartItem com valores copiados e/ou modificados.
  CartItem copyWith({Product? product, int? quantity}) {
    return CartItem(
      product: product ?? this.product,
      quantity: quantity ?? this.quantity,
    );
  }
}

/// Representa o estado atual da autenticação do usuário.
class AuthState {
  final bool isLoading;
  final bool isAuthed;
  final String? error;
  final bool? isEmailError;
  final UserProfile? currentUser;

  /// Construtor constante para criar uma nova instância de AuthState com valores padrão.
  const AuthState({
    this.isLoading = false,
    this.isAuthed = false,
    this.error,
    this.isEmailError,
    this.currentUser,
  });

  /// Cria uma nova instância de AuthState com valores copiados e/ou modificados.
  AuthState copyWith({
    bool? isLoading,
    bool? isAuthed,
    String? error,
    bool? isEmailError,
    UserProfile? currentUser,
  }) =>
      AuthState(
        isLoading: isLoading ?? this.isLoading,
        isAuthed: isAuthed ?? this.isAuthed,
        error: error,
        isEmailError: isEmailError,
        currentUser: currentUser,
      );
}

/// Classe interna para armazenar detalhes de usuários registrados (email, senha, perfil).
class _RegisteredUserDetails {
  final String password;
  final UserProfile userProfile;

  /// Construtor para criar uma nova instância de _RegisteredUserDetails.
  _RegisteredUserDetails({required this.password, required this.userProfile});
}

/// Representa um serviço agendável.
class Service {
  final int id;
  String name;
  String description;
  double price;
  int durationMinutes; // Duração do serviço em minutos
  String? imageUrl;

  /// Construtor para criar uma nova instância de Service.
  Service({
    required this.id,
    required this.name,
    required this.description,
    required this.price,
    required this.durationMinutes,
    this.imageUrl,
  });

  /// Cria uma nova instância de Service com valores copiados e/ou modificados.
  Service copyWith({
    int? id,
    String? name,
    String? description,
    double? price,
    int? durationMinutes,
    String? imageUrl,
  }) =>
      Service(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        price: price ?? this.price,
        durationMinutes: durationMinutes ?? this.durationMinutes,
        imageUrl: imageUrl ?? this.imageUrl,
      );
}

/// Enum para representar o status de uma reserva.
enum ReservationStatus {
  pending('Pendente', Icons.access_time, Colors.orange),
  confirmed('Confirmada', Icons.check_circle_outline, Colors.green),
  cancelled('Cancelada', Icons.cancel_outlined, Colors.red),
  completed('Concluída', Icons.task_alt, Colors.blueGrey);

  final String displayName;
  final IconData icon;
  final Color color;

  const ReservationStatus(this.displayName, this.icon, this.color);
}

/// Representa uma reserva de serviço.
class Reservation {
  final int id;
  final int userId;
  final String userName;
  final int serviceId;
  final String serviceName;
  final DateTime reservationDateTime;
  final ReservationStatus status;
  final String? notes;

  /// Construtor para criar uma nova instância de Reservation.
  Reservation({
    required this.id,
    required this.userId,
    required this.userName,
    required this.serviceId,
    required this.serviceName,
    required this.reservationDateTime,
    this.status = ReservationStatus.pending,
    this.notes,
  });

  /// Cria uma nova instância de Reservation com valores copiados e/ou modificados.
  Reservation copyWith({
    int? id,
    int? userId,
    String? userName,
    int? serviceId,
    String? serviceName,
    DateTime? reservationDateTime,
    ReservationStatus? status,
    String? notes,
  }) =>
      Reservation(
        id: id ?? this.id,
        userId: userId ?? this.userId,
        userName: userName ?? this.userName,
        serviceId: serviceId ?? this.serviceId,
        serviceName: serviceName ?? this.serviceName,
        reservationDateTime: reservationDateTime ?? this.reservationDateTime,
        status: status ?? this.status,
        notes: notes ?? this.notes,
      );
}

// ------------------------------
// State Notifiers (Controllers)
// ------------------------------

/// Gerencia o estado de autenticação do usuário.
class AuthController extends StateNotifier<AuthState> {
  final Ref _ref; // Adicionado para permitir acesso a outros provedores
  /// Construtor que inicializa o estado com AuthState padrão.
  AuthController(this._ref) : super(const AuthState());

  static const String _fixedUserEmail = 'admin@vet.com';
  static const String _fixedUserPass = '123456';
  static const String _fixedUserName = 'Admin Vet';

  // Mapa para armazenar detalhes de usuários registrados dinamicamente.
  final Map<String, _RegisteredUserDetails> _registeredUsersDetails = {};

  /// Tenta fazer login com o email e senha fornecidos.
  Future<void> login(String email, String pass) async {
    // Define o estado para isLoading (carregando) e limpa quaisquer erros anteriores.
    state = state.copyWith(isLoading: true, error: null, isEmailError: null, currentUser: null);
    await Future.delayed(const Duration(milliseconds: 800)); // Simula um atraso de rede.

    bool isAuthenticated = false;
    UserProfile? userProfile;

    // Verifica se as credenciais correspondem ao usuário fixo.
    if (email == _fixedUserEmail && pass == _fixedUserPass) {
      isAuthenticated = true;
      userProfile = UserProfile(id: 1, name: _fixedUserName, email: email);
    }
    // Ou verifica se as credenciais correspondem a um usuário registrado dinamicamente.
    else if (_registeredUsersDetails.containsKey(email) && _registeredUsersDetails[email]!.password == pass) {
      isAuthenticated = true;
      userProfile = _registeredUsersDetails[email]!.userProfile;
    }

    // Atualiza o estado com base no resultado da autenticação.
    if (isAuthenticated) {
      state = state.copyWith(
          isAuthed: true,
          isLoading: false,
          error: null,
          isEmailError: null,
          currentUser: userProfile);
    } else {
      state = state.copyWith(
          isAuthed: false,
          isLoading: false,
          error: 'Cadastro inválido.',
          isEmailError: false,
          currentUser: null);
    }
  }

  /// Tenta registrar um novo usuário com o email, senha e nome fornecidos.
  Future<void> register(String email, String password, String name) async {
    // Define o estado para isLoading (carregando) e limpa quaisquer erros anteriores.
    state = state.copyWith(isLoading: true, error: null, isEmailError: null, currentUser: null);
    await Future.delayed(const Duration(milliseconds: 1200)); // Simula um atraso de rede.

    // Verifica se o email já está registrado (fixo ou dinâmico).
    if (_registeredUsersDetails.containsKey(email) || email == _fixedUserEmail) {
      state = state.copyWith(isLoading: false, error: 'Este email já está cadastrado.', isEmailError: true);
      return;
    }

    // Cria um novo perfil de usuário.
    final UserProfile newUserProfile = UserProfile(id: email.hashCode.abs(), name: name, email: email);
    // Armazena os detalhes do novo usuário.
    _registeredUsersDetails[email] = _RegisteredUserDetails(password: password, userProfile: newUserProfile);

    // Atualiza o estado indicando sucesso (sem erro e sem carregamento).
    state = state.copyWith(isLoading: false, error: null, isEmailError: null);
  }

  /// Desloga o usuário, redefinindo o estado de autenticação para o padrão.
  /// Também limpa o carrinho de compras e os favoritos.
  void logout() {
    state = const AuthState();
    _ref.read(cartProvider.notifier).clearCart(); // Limpa o carrinho
    _ref.read(favoriteProvider.notifier).state = <int>[]; // Limpa os favoritos
    _ref.read(reservationProvider.notifier).clearAllReservations(); // Limpa as reservas
  }
}

/// Gerencia a lista de produtos disponíveis.
class ProductController extends StateNotifier<List<Product>> {
  /// Construtor que inicializa o estado com uma lista de produtos iniciais.
  ProductController() : super(_initialProducts);

  static const List<String> availableCategories = <String>['Remédios', 'Rações', 'Brinquedos'];

  // Lista estática de produtos iniciais.
  static final List<Product> _initialProducts = <Product>[
    Product(
      id: 101,
      name: 'Anti-pulgas PetGuard',
      description: 'Proteção eficaz contra pulgas e carrapatos por 3 meses.',
      price: 89.90,
      rxOnly: false,
      imageUrl: 'https://images.tcdn.com.br/img/img_prod/469080/nexgard_antipulgas_caes_p_2kg_a_4kg_1_comprimido_boehringer_432_1_13f003e9c4b9fe1c31c67d5f5fb8f05f.png',
      category: 'Remédios',
    ),
    Product(
      id: 102,
      name: 'Antibiótico AmoxPet 250mg',
      description: 'Antibiótico de amplo espectro para infecções bacterianas.',
      price: 65.50,
      rxOnly: true,
      imageUrl: 'https://agrosolo.fbitsstatic.net/img/p/antibiotico-doxiciclina-doxitec-200mg-para-caes-16-comprimidos-89123/284689.jpg?w=700&h=700&v=202504291638',
      category: 'Remédios',
    ),
    Product(
      id: 103,
      name: 'Vermífugo CanineCare',
      description: 'Combate vermes intestinais em cães e gatos.',
      price: 35.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT8DWzbB9P9VERuidx9GwdwebtgsszUawJ9lw&s',
      category: 'Remédios',
    ),
    Product(
      id: 201,
      name: 'Ração Premium DogFit',
      description: 'Alimento completo e balanceado para cães adultos.',
      price: 120.00,
      rxOnly: false,
      imageUrl: 'https://www.petlove.com.br/images/products/273209/product/31027529907_Ra%C3%A7%C3%A3o_Seca_Dogfit_Gourmet_Carne_e_Vegetais_para_C%C3%A3es_Adultos_Porte_Pequeno_e_M%C3%A9dio_%281%29.jpg?1694521363',
      category: 'Rações',
    ),
    Product(
      id: 202,
      name: 'Ração Hipoalergênica CatHealthy',
      description: 'Fórmula especial para gatos com sensibilidade alimentar.',
      price: 95.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTowFVywEowD88opffFHbChTD67XcEtLfv1Ug&s',
      category: 'Rações',
    ),
    Product(
      id: 203,
      name: 'Petisco Dental Bites',
      description: 'Ajuda a reduzir o tártaro e manter a higiene bucal.',
      price: 25.00,
      rxOnly: false,
      imageUrl: 'https://http2.mlstatic.com/D_NQ_NP_605948-MLB47205197255_082021-O.webp',
      category: 'Rações',
    ),
    Product(
      id: 301,
      name: 'Bola Interativa PetPlay',
      description: 'Bola com dispenser de petiscos, estimula o raciocínio.',
      price: 45.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR3KF-xAehT3_BC-l6WPI866EPVZFkCwAzdtw&s',
      category: 'Brinquedos',
    ),
    Product(
      id: 302,
      name: 'Arranhador para Gatos Tower',
      description: 'Torre de arranhar com várias plataformas e brinquedos pendurados.',
      price: 180.00,
      rxOnly: false,
      imageUrl: 'https://m.media-amazon.com/images/I/61aAaZAExuL._UF1000,1000_QL80_.jpg',
      category: 'Brinquedos',
    ),
    Product(
      id: 303,
      name: 'Corda de Roer para Cães',
      description: 'Brinquedo resistente para cães que adoram mastigar.',
      price: 30.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRbsbIIMKHjDlNv4hP7ZSH0a9-ZQ5xGslEbPw&s',
      category: 'Brinquedos',
    ),
  ];

  /// Adiciona um novo produto à lista.
  void addProduct(Product product) {
    // Generate a unique ID for the new product
    final int newId = DateTime.now().microsecondsSinceEpoch;
    final Product newProductWithId = product.copyWith(id: newId);
    state = <Product>[...state, newProductWithId];
  }

  /// Atualiza um produto existente na lista.
  void updateProduct(Product updatedProduct) {
    state = state.map<Product>((Product p) => p.id == updatedProduct.id ? updatedProduct : p).toList();
  }

  /// Remove um produto da lista pelo seu ID.
  void deleteProduct(int productId) {
    state = state.where((Product p) => p.id != productId).toList();
  }

  /// Retorna uma lista de produtos filtrados por categoria.
  List<Product> getProductsByCategory(String category) {
    return state.where((Product product) => product.category == category).toList();
  }
}

/// Gerencia o estado do carrinho de compras.
class CartController extends StateNotifier<List<CartItem>> {
  /// Construtor que inicializa o estado com uma lista de itens vazia.
  CartController() : super(<CartItem>[]);

  /// Adiciona um produto ao carrinho ou aumenta sua quantidade se já existir.
  void addItem(Product product) {
    final List<CartItem> currentCart = List<CartItem>.from(state);
    final int index = currentCart.indexWhere((CartItem item) => item.product.id == product.id);

    if (index != -1) {
      final CartItem existingItem = currentCart[index];
      currentCart[index] = existingItem.copyWith(quantity: existingItem.quantity + 1);
    } else {
      currentCart.add(CartItem(product: product, quantity: 1));
    }
    state = currentCart;
  }

  /// Remove uma unidade de um produto do carrinho ou o remove completamente se a quantidade for 1.
  void removeItem(Product product) {
    final List<CartItem> currentCart = List<CartItem>.from(state);
    final int index = currentCart.indexWhere((CartItem item) => item.product.id == product.id);

    if (index != -1) {
      final CartItem existingItem = currentCart[index];
      if (existingItem.quantity > 1) {
        currentCart[index] = existingItem.copyWith(quantity: existingItem.quantity - 1);
      } else {
        currentCart.removeAt(index);
      }
      state = currentCart;
    }
  }

  /// Remove todas as unidades de um produto específico do carrinho.
  void removeAllItemsOfProduct(Product product) {
    state = state.where((CartItem item) => item.product.id != product.id).toList();
  }

  /// Esvazia completamente o carrinho.
  void clearCart() {
    state = <CartItem>[];
  }

  /// Calcula o preço total de todos os itens no carrinho.
  double getTotalPrice() {
    return state.fold<double>(
        0.0, (double previousValue, CartItem item) => previousValue + (item.product.price * item.quantity));
  }

  /// Calcula a quantidade total de itens (unidades) no carrinho.
  int getTotalQuantity() {
    return state.fold<int>(
        0, (int previousValue, CartItem item) => previousValue + item.quantity);
  }

  /// Verifica se um produto específico está no carrinho.
  bool isInCart(Product product) {
    return state.any((CartItem item) => item.product.id == product.id);
  }

  /// Retorna a quantidade de um produto específico no carrinho.
  int getProductQuantity(Product product) {
    final CartItem? item = state.firstWhereOrNull((CartItem item) => item.product.id == product.id);
    return item?.quantity ?? 0;
  }
}

/// Gerencia a lista de produtos favoritos do usuário.
class FavoriteController extends StateNotifier<List<int>> {
  /// Construtor que inicializa o estado com uma lista vazia de IDs de produtos favoritos.
  FavoriteController() : super(<int>[]);

  /// Alterna o status de favorito de um produto.
  void toggleFavorite(int productId) {
    if (state.contains(productId)) {
      // Se o produto já é favorito, remove-o da lista.
      state = state.where((int id) => id != productId).toList();
    } else {
      // Se o produto não é favorito, adiciona-o à lista.
      state = <int>[...state, productId];
    }
  }

  /// Verifica se um produto é favorito.
  bool isFavorite(int productId) {
    return state.contains(productId);
  }
}

/// Gerencia a lista de serviços disponíveis.
class ServiceController extends StateNotifier<List<Service>> {
  /// Construtor que inicializa o estado com uma lista de serviços iniciais.
  ServiceController() : super(_initialServices);

  // Lista estática de serviços iniciais.
  static final List<Service> _initialServices = <Service>[
    Service(
      id: 1,
      name: 'Consulta Veterinária',
      description: 'Consulta geral com um veterinário experiente para check-up ou avaliação de sintomas.',
      price: 150.00,
      durationMinutes: 45,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTcApM5qMstjZBkBpZnqKHh6o-qId3Li0oqsg&s',
    ),
    Service(
      id: 2,
      name: 'Vacinação',
      description: 'Aplicação de vacinas anuais ou de reforço para cães e gatos.',
      price: 80.00,
      durationMinutes: 30,
      imageUrl: 'https://lh5.googleusercontent.com/proxy/Tx8ONB4BX49wi8XyQTbVe_8nV9TvdON4VaR7pd6T5Z5kkmo5by4Zo4VtDXCmC8SuQRucV60G9AcmtvsuVoZcJTwZXA0IbJQALesnlOCVcUUoUPLpzaFNi_XO2We-YJVgVuSeOEmUuAX8kDtrLufGA68dPi8WagKUPxaApH5MyQhn-86WVMie0kwyzxY',
    ),
    Service(
      id: 3,
      name: 'Banho e Tosa',
      description: 'Serviço completo de banho, tosa e higiene para seu pet.',
      price: 100.00,
      durationMinutes: 90,
      imageUrl: 'https://cdn-hjdpmen.nitrocdn.com/OdygPLcrrLyxbRgOKEndAYjdoPblKJCR/assets/images/optimized/rev-3bad09d/www.hovetpopular24h.com.br/wp-content/uploads/2020/07/estetica.png',
    ),
    Service(
      id: 4,
      name: 'Exame de Sangue',
      description: 'Coleta e análise de amostra de sangue para diagnóstico e acompanhamento.',
      price: 120.00,
      durationMinutes: 20,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcQPxwXgMwlrLge_6mmktzWCafSPmQnumW1JhQ&s',
    ),
  ];

  /// Retorna um serviço pelo seu ID.
  Service? getServiceById(int id) {
    return state.firstWhereOrNull((Service s) => s.id == id);
  }
}

/// Gerencia a lista de reservas.
class ReservationController extends StateNotifier<List<Reservation>> {
  ReservationController() : super(<Reservation>[]);

  /// Adiciona uma nova reserva.
  void makeReservation(Reservation newReservation) {
    final int newId = DateTime.now().microsecondsSinceEpoch;
    state = <Reservation>[...state, newReservation.copyWith(id: newId)];
  }

  /// Atualiza o status de uma reserva existente.
  void updateReservationStatus(int reservationId, ReservationStatus newStatus) {
    state = state.map<Reservation>((Reservation r) {
      return r.id == reservationId ? r.copyWith(status: newStatus) : r;
    }).toList();
  }

  /// Cancela uma reserva (muda o status para cancelado).
  void cancelReservation(int reservationId) {
    updateReservationStatus(reservationId, ReservationStatus.cancelled);
  }

  /// Retorna todas as reservas de um usuário específico.
  List<Reservation> getReservationsForUser(int userId) {
    return state.where((Reservation r) => r.userId == userId).toList();
  }

  /// Limpa todas as reservas (útil para logout).
  void clearAllReservations() {
    state = <Reservation>[];
  }
}

// ------------------------------
// Riverpod Providers (Provedores Riverpod)
// ------------------------------

/// Provedor para o AuthController, gerenciando o estado de autenticação.
final authProvider = StateNotifierProvider<AuthController, AuthState>((ref) {
  return AuthController(ref);
});

/// Provedor para o ProductController, gerenciando a lista de produtos.
final productProvider = StateNotifierProvider<ProductController, List<Product>>((ref) {
  return ProductController();
});

/// Provedor para o CartController, gerenciando o carrinho de compras.
final cartProvider = StateNotifierProvider<CartController, List<CartItem>>((ref) {
  return CartController();
});

/// Provedor para o FavoriteController, gerenciando a lista de produtos favoritos.
final favoriteProvider = StateNotifierProvider<FavoriteController, List<int>>((ref) {
  return FavoriteController();
});

/// Provedor para o ServiceController, gerenciando a lista de serviços disponíveis.
final serviceProvider = StateNotifierProvider<ServiceController, List<Service>>((ref) {
  return ServiceController();
});

/// Provedor para o ReservationController, gerenciando as reservas.
final reservationProvider = StateNotifierProvider<ReservationController, List<Reservation>>((ref) {
  return ReservationController();
});

// ------------------------------
// UI Widgets (Widgets da Interface do Usuário)
// ------------------------------

/// Tela exibida após um registro bem-sucedido.
class RegistrationSuccessScreen extends StatelessWidget {
  final String registeredEmail;
  final String registeredName;

  /// Construtor para RegistrationSuccessScreen.
  const RegistrationSuccessScreen({super.key, required this.registeredEmail, required this.registeredName});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Cadastro Concluído'),
        automaticallyImplyLeading: false,
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Icons.check_circle_outline, size: 90, color: Colors.green),
              const SizedBox(height: 32.0),
              Text(
                'Parabéns, $registeredName!',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.green,
                      fontWeight: FontWeight.bold,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16.0),
              Text(
                'Sua conta para "$registeredEmail" foi criada com sucesso.',
                style: Theme.of(context).textTheme.titleMedium,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32.0),
              ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop();
                },
                child: const Text('Voltar para o Login'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Tela de login para os usuários.
class LoginScreen extends ConsumerStatefulWidget {
  /// Construtor para LoginScreen.
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  String? _emailLocalError;
  String? _passwordLocalError;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider);

    String? emailAuthError;
    String? passwordAuthError;

    if (authState.error != null && !authState.isLoading && !authState.isAuthed) {
      if (authState.isEmailError == true) {
        emailAuthError = authState.error;
      } else if (authState.isEmailError == false) {
        passwordAuthError = authState.error;
      }
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Entrar no Sistema'),
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Icons.pets, size: 90, color: Colors.pinkAccent),
              const SizedBox(height: 32.0),
              Text(
                'Bem-vindo ao VetApp',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.pinkAccent,
                      fontWeight: FontWeight.bold,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32.0),
              TextField(
                controller: _emailController,
                onChanged: (_) {
                  if (_emailLocalError != null) {
                    setState(() => _emailLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Email',
                  prefixIcon: const Icon(Icons.email),
                  hintText: 'admin@vet.com',
                  errorText: _emailLocalError ?? emailAuthError,
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16.0),
              TextField(
                controller: _passwordController,
                onChanged: (_) {
                  if (_passwordLocalError != null) {
                    setState(() => _passwordLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Senha',
                  prefixIcon: const Icon(Icons.lock),
                  hintText: '123456',
                  errorText: _passwordLocalError ?? passwordAuthError,
                ),
                obscureText: true,
              ),
              const SizedBox(height: 32.0),
              if (authState.isLoading)
                const CircularProgressIndicator()
              else
                ElevatedButton(
                  onPressed: () {
                    final String email = _emailController.text.trim();
                    final String password = _passwordController.text.trim();

                    bool hasLocalError = false;
                    String? tempEmailError;
                    String? tempPasswordError;

                    if (email.isEmpty) {
                      tempEmailError = 'Por favor, preencha seu email.';
                      hasLocalError = true;
                    }
                    if (password.isEmpty) {
                      tempPasswordError = 'Por favor, preencha sua senha.';
                      hasLocalError = true;
                    }

                    setState(() {
                      _emailLocalError = tempEmailError;
                      _passwordLocalError = tempPasswordError;
                    });

                    if (hasLocalError) {
                      return;
                    }

                    ref.read(authProvider.notifier).state = authState.copyWith(error: null, isEmailError: null);
                    ref.read(authProvider.notifier).login(email, password);
                  },
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size.fromHeight(50),
                  ),
                  child: const Text('Login'),
                ),
              const SizedBox(height: 20.0),
              TextButton(
                onPressed: () {
                  ref.read(authProvider.notifier).state =
                      ref.read(authProvider.notifier).state.copyWith(error: null, isEmailError: null);
                  Navigator.of(context).push(
                    MaterialPageRoute<void>(
                      builder: (BuildContext context) => const RegisterScreen(),
                    ),
                  );
                },
                child: const Text(
                  'Não tem uma conta? Cadastre-se aqui!',
                  style: TextStyle(color: Colors.pinkAccent, fontSize: 16),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Tela de registro para novos usuários.
class RegisterScreen extends ConsumerStatefulWidget {
  /// Construtor para RegisterScreen.
  const RegisterScreen({super.key});

  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final TextEditingController _nameController = TextEditingController();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  String? _nameLocalError;
  String? _emailLocalError;
  String? _passwordLocalError;

  @override
  void dispose() {
    _nameController.dispose();
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider);

    String? emailAuthError;

    if (authState.error != null && !authState.isLoading) {
      if (authState.isEmailError == true) {
        emailAuthError = authState.error;
      }
    }

    ref.listen<AuthState>(authProvider, (AuthState? previous, AuthState current) {
      if (previous?.isLoading == true && !current.isLoading && current.error == null) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute<void>(
            builder: (BuildContext context) => RegistrationSuccessScreen(
              registeredEmail: _emailController.text,
              registeredName: _nameController.text,
            ),
          ),
        );
      }
    });

    return Scaffold(
      appBar: AppBar(
        title: const Text('Cadastro de Usuário'),
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Icons.person_add, size: 90, color: Colors.pinkAccent),
              const SizedBox(height: 32.0),
              Text(
                'Criar Nova Conta',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.pinkAccent,
                      fontWeight: FontWeight.bold,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32.0),
              TextField(
                controller: _nameController,
                onChanged: (_) {
                  if (_nameLocalError != null) {
                    setState(() => _nameLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Nome Completo',
                  prefixIcon: const Icon(Icons.person),
                  hintText: 'Seu nome',
                  errorText: _nameLocalError,
                ),
                keyboardType: TextInputType.name,
              ),
              const SizedBox(height: 16.0),
              TextField(
                controller: _emailController,
                onChanged: (_) {
                  if (_emailLocalError != null) {
                    setState(() => _emailLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Email',
                  prefixIcon: const Icon(Icons.email),
                  hintText: 'seu.email@exemplo.com',
                  errorText: _emailLocalError ?? emailAuthError,
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16.0),
              TextField(
                controller: _passwordController,
                onChanged: (_) {
                  if (_passwordLocalError != null) {
                    setState(() => _passwordLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Senha',
                  prefixIcon: const Icon(Icons.lock),
                  hintText: '****',
                  errorText: _passwordLocalError,
                ),
                obscureText: true,
              ),
              const SizedBox(height: 32.0),
              if (authState.isLoading)
                const CircularProgressIndicator()
              else
                ElevatedButton(
                  onPressed: () {
                    final String name = _nameController.text.trim();
                    final String email = _emailController.text.trim();
                    final String password = _passwordController.text.trim();

                    bool hasLocalError = false;
                    String? tempNameError;
                    String? tempEmailError;
                    String? tempPasswordError;

                    if (name.isEmpty) {
                      tempNameError = 'Por favor, preencha seu nome.';
                      hasLocalError = true;
                    }
                    if (email.isEmpty) {
                      tempEmailError = 'Por favor, preencha seu email para cadastro.';
                      hasLocalError = true;
                    }
                    if (password.isEmpty) {
                      tempPasswordError = 'Por favor, preencha sua senha para cadastro.';
                      hasLocalError = true;
                    }

                    setState(() {
                      _nameLocalError = tempNameError;
                      _emailLocalError = tempEmailError;
                      _passwordLocalError = tempPasswordError;
                    });

                    if (hasLocalError) {
                      return;
                    }

                    ref.read(authProvider.notifier).state = authState.copyWith(error: null, isEmailError: null);
                    ref.read(authProvider.notifier).register(email, password, name);
                  },
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size.fromHeight(50),
                  ),
                  child: const Text('Cadastrar'),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Cartão de exibição para um único produto.
class ProductCard extends ConsumerWidget {
  final Product product;

  /// Construtor para ProductCard.
  const ProductCard({super.key, required this.product});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                ClipRRect(
                  borderRadius: BorderRadius.circular(8.0),
                  child: Image.network(
                    product.imageUrl ?? 'https://www.gstatic.com/flutter-onestack-prototype/genui/example_1.jpg',
                    width: 80,
                    height: 80,
                    fit: BoxFit.cover,
                    errorBuilder: (BuildContext context, Object error, StackTrace? stackTrace) => Container(
                      width: 80,
                      height: 80,
                      color: Colors.grey[200],
                      child: const Icon(Icons.image_not_supported, color: Colors.grey),
                    ),
                  ),
                ),
                const SizedBox(width: 16.0),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: <Widget>[
                      Text(
                        product.name,
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 4.0),
                      Text(
                        product.description,
                        style: Theme.of(context).textTheme.bodyMedium,
                        maxLines: 3,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 8.0),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: <Widget>[
                          Text(
                            'R\$ ${product.price.toStringAsFixed(2)}',
                            style: Theme.of(context)
                                .textTheme.titleSmall?.copyWith(color: Colors.green[700], fontWeight: FontWeight.bold),
                          ),
                          if (product.rxOnly)
                            Chip(
                              label: const Text('Com receita', style: TextStyle(fontSize: 12, color: Colors.white)),
                              backgroundColor: Colors.red[400],
                              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                            ),
                        ],
                      ),
                    ],
                  ),
                ),
                Consumer(
                  builder: (BuildContext context, WidgetRef ref, Widget? child) {
                    final bool isProductFavorite = ref.watch(favoriteProvider).contains(product.id);
                    return Align(
                      alignment: Alignment.topRight,
                      child: IconButton(
                        icon: Icon(
                          isProductFavorite ? Icons.favorite : Icons.favorite_border,
                          color: isProductFavorite ? Colors.red : Colors.grey,
                        ),
                        onPressed: () {
                          ref.read(favoriteProvider.notifier).toggleFavorite(product.id);
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(
                              content: Text(isProductFavorite
                                  ? '${product.name} removido dos favoritos!'
                                  : '${product.name} adicionado aos favoritos!'),
                              duration: const Duration(seconds: 1),
                            ),
                          );
                        },
                      ),
                    );
                  },
                ),
              ],
            ),
            const SizedBox(height: 16.0),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.add_shopping_cart, size: 20),
                label: const Text('Adicionar ao Carrinho', style: TextStyle(fontSize: 16)),
                onPressed: () {
                  ref.read(cartProvider.notifier).addItem(product);
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('${product.name} adicionado ao carrinho!'),
                      duration: const Duration(seconds: 1),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Tela de exibição do carrinho de compras.
class CartScreen extends ConsumerWidget {
  /// Construtor para CartScreen.
  const CartScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<CartItem> cartItems = ref.watch(cartProvider);
    final CartController cartController = ref.read(cartProvider.notifier);
    final double totalPrice = cartController.getTotalPrice();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Meu Carrinho'),
      ),
      body: cartItems.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Icon(Icons.shopping_cart_outlined, size: 90, color: Colors.grey),
                  const SizedBox(height: 24),
                  Text(
                    'Seu carrinho está vazio!',
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey[600]),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      Navigator.of(context).pop();
                    },
                    child: const Text('Continuar Comprando'),
                  ),
                ],
              ),
            )
          : Column(
              children: <Widget>[
                Expanded(
                  child: ListView.builder(
                    padding: const EdgeInsets.all(16.0),
                    itemCount: cartItems.length,
                    itemBuilder: (BuildContext context, int index) {
                      final CartItem item = cartItems[index];
                      return Card(
                        margin: const EdgeInsets.symmetric(vertical: 8.0),
                        elevation: 2,
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
                        child: Padding(
                          padding: const EdgeInsets.all(16.0),
                          child: Row(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: <Widget>[
                              ClipRRect(
                                borderRadius: BorderRadius.circular(8.0),
                                child: Image.network(
                                  item.product.imageUrl ?? 'https://www.gstatic.com/flutter-onestack-prototype/genui/example_1.jpg',
                                  width: 60,
                                  height: 60,
                                  fit: BoxFit.cover,
                                  errorBuilder: (BuildContext context, Object error, StackTrace? stackTrace) => Container(
                                    width: 60,
                                    height: 60,
                                    color: Colors.grey[200],
                                    child: const Icon(Icons.image_not_supported, color: Colors.grey),
                                  ),
                                ),
                              ),
                              const SizedBox(width: 16.0),
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start,
                                  children: <Widget>[
                                    Text(
                                      item.product.name,
                                      style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                                      maxLines: 2,
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                    const SizedBox(height: 4.0),
                                    Text(
                                      'R\$ ${item.product.price.toStringAsFixed(2)}',
                                      style: Theme.of(context)
                                          .textTheme.titleSmall?.copyWith(color: Colors.green[700]),
                                    ),
                                    const SizedBox(height: 8.0),
                                    Row(
                                      children: <Widget>[
                                        IconButton(
                                          icon: const Icon(Icons.remove_circle_outline, color: Colors.red),
                                          onPressed: () => cartController.removeItem(item.product),
                                        ),
                                        Text(
                                          '${item.quantity}',
                                          style: Theme.of(context).textTheme.titleMedium,
                                        ),
                                        IconButton(
                                          icon: const Icon(Icons.add_circle_outline, color: Colors.green),
                                          onPressed: () => cartController.addItem(item.product),
                                        ),
                                        const Spacer(),
                                        IconButton(
                                          icon: const Icon(Icons.delete, color: Colors.grey),
                                          onPressed: () => cartController.removeAllItemsOfProduct(item.product),
                                        ),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      );
                    },
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: <Widget>[
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: <Widget>[
                          Text(
                            'Total:',
                            style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
                          ),
                          Text(
                            'R\$ ${totalPrice.toStringAsFixed(2)}',
                            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                                  fontWeight: FontWeight.bold,
                                  color: Colors.green[700],
                                ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16),
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton.icon(
                          icon: const Icon(Icons.payment),
                          label: const Text('Finalizar Compra'),
                          onPressed: () {
                            if (cartItems.isNotEmpty) {
                              cartController.clearCart();
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Compra finalizada com sucesso!'),
                                  duration: Duration(seconds: 2),
                                ),
                              );
                              Navigator.of(context).pop();
                            }
                          },
                        ),
                      ),
                      const SizedBox(height: 8),
                      SizedBox(
                        width: double.infinity,
                        child: TextButton.icon(
                          icon: const Icon(Icons.remove_shopping_cart, color: Colors.red),
                          label: const Text('Limpar Carrinho', style: TextStyle(color: Colors.red)),
                          onPressed: () {
                            if (cartItems.isNotEmpty) {
                              cartController.clearCart();
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Carrinho esvaziado!'),
                                  duration: Duration(seconds: 1),
                                ),
                              );
                            }
                          },
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
    );
  }
}

/// Cartão de exibição para um item favorito.
class FavoriteItemCard extends ConsumerWidget {
  final Product product;

  /// Construtor para FavoriteItemCard.
  const FavoriteItemCard({super.key, required this.product});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            ClipRRect(
              borderRadius: BorderRadius.circular(8.0),
              child: Image.network(
                product.imageUrl ?? 'https://www.gstatic.com/flutter-onestack-prototype/genui/example_1.jpg',
                width: 60,
                height: 60,
                fit: BoxFit.cover,
                errorBuilder: (BuildContext context, Object error, StackTrace? stackTrace) => Container(
                  width: 60,
                  height: 60,
                  color: Colors.grey[200],
                  child: const Icon(Icons.image_not_supported, color: Colors.grey),
                ),
              ),
            ),
            const SizedBox(width: 16.0),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: <Widget>[
                  Text(
                    product.name,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4.0),
                  Text(
                    'R\$ ${product.price.toStringAsFixed(2)}',
                    style: Theme.of(context)
                        .textTheme.titleSmall?.copyWith(color: Colors.green[700]),
                  ),
                  if (product.rxOnly) ...<Widget>[
                    const SizedBox(height: 4.0),
                    Chip(
                      label: const Text('Com receita', style: TextStyle(fontSize: 12, color: Colors.white)),
                      backgroundColor: Colors.red[400],
                      materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                    ),
                  ],
                ],
              ),
            ),
            IconButton(
              icon: const Icon(Icons.favorite, color: Colors.red),
              onPressed: () {
                ref.read(favoriteProvider.notifier).toggleFavorite(product.id);
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text('${product.name} removido dos favoritos!'),
                    duration: const Duration(seconds: 1),
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}

/// Tela para exibir produtos favoritos.
class FavoritesScreen extends ConsumerWidget {
  /// Construtor para FavoritesScreen.
  const FavoritesScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<int> favoriteProductIds = ref.watch(favoriteProvider);
    final List<Product> allProducts = ref.watch(productProvider);

    final List<Product> favoriteProducts = allProducts
        .where((Product product) => favoriteProductIds.contains(product.id))
        .toList();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Meus Favoritos'),
      ),
      body: favoriteProducts.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Icon(Icons.favorite_border, size: 90, color: Colors.grey),
                  const SizedBox(height: 24),
                  Text(
                    'Você não tem produtos favoritos ainda!',
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey[600]),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      Navigator.of(context).pop();
                    },
                    child: const Text('Começar a Favoritar'),
                  ),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16.0),
              itemCount: favoriteProducts.length,
              itemBuilder: (BuildContext context, int index) {
                final Product product = favoriteProducts[index];
                return FavoriteItemCard(product: product);
              },
            ),
    );
  }
}

/// Formulário para adicionar ou editar um produto.
class ProductFormScreen extends ConsumerStatefulWidget {
  final Product? product;

  const ProductFormScreen({super.key, this.product});

  @override
  ConsumerState<ProductFormScreen> createState() => _ProductFormScreenState();
}

class _ProductFormScreenState extends ConsumerState<ProductFormScreen> {
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  late TextEditingController _nameController;
  late TextEditingController _descriptionController;
  late TextEditingController _priceController;
  late TextEditingController _imageUrlController;
  late bool _rxOnly;
  late String _selectedCategory;

  @override
  void initState() {
    super.initState();
    _nameController = TextEditingController(text: widget.product?.name ?? '');
    _descriptionController = TextEditingController(text: widget.product?.description ?? '');
    _priceController = TextEditingController(text: widget.product?.price.toStringAsFixed(2) ?? '');
    _imageUrlController = TextEditingController(text: widget.product?.imageUrl ?? '');
    _rxOnly = widget.product?.rxOnly ?? false;
    _selectedCategory = widget.product?.category ?? ProductController.availableCategories.first;
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _priceController.dispose();
    _imageUrlController.dispose();
    super.dispose();
  }

  void _saveProduct() {
    if (_formKey.currentState!.validate()) {
      final String name = _nameController.text.trim();
      final String description = _descriptionController.text.trim();
      final double price = double.parse(_priceController.text.replaceAll(',', '.'));
      final String? imageUrl = _imageUrlController.text.trim().isEmpty ? null : _imageUrlController.text.trim();

      final Product newOrUpdatedProduct = Product(
        id: widget.product?.id ?? 0, // ID will be generated by controller if new
        name: name,
        description: description,
        price: price,
        rxOnly: _rxOnly,
        imageUrl: imageUrl,
        category: _selectedCategory,
      );

      if (widget.product == null) {
        // Adding new product
        ref.read(productProvider.notifier).addProduct(newOrUpdatedProduct);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('${name} adicionado com sucesso!')),
        );
      } else {
        // Updating existing product
        ref.read(productProvider.notifier).updateProduct(newOrUpdatedProduct);
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('${name} atualizado com sucesso!')),
        );
      }
      Navigator.of(context).pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(widget.product == null ? 'Adicionar Produto' : 'Editar Produto'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            children: <Widget>[
              TextFormField(
                controller: _nameController,
                decoration: const InputDecoration(
                  labelText: 'Nome do Produto',
                  prefixIcon: Icon(Icons.shopping_bag),
                ),
                validator: (String? value) {
                  if (value == null || value.isEmpty) {
                    return 'O nome do produto não pode ser vazio.';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _descriptionController,
                decoration: const InputDecoration(
                  labelText: 'Descrição',
                  prefixIcon: Icon(Icons.description),
                ),
                maxLines: 3,
                validator: (String? value) {
                  if (value == null || value.isEmpty) {
                    return 'A descrição não pode ser vazia.';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _priceController,
                decoration: const InputDecoration(
                  labelText: 'Preço',
                  prefixIcon: Icon(Icons.attach_money),
                ),
                keyboardType: const TextInputType.numberWithOptions(decimal: true),
                validator: (String? value) {
                  if (value == null || value.isEmpty) {
                    return 'O preço não pode ser vazio.';
                  }
                  if (double.tryParse(value.replaceAll(',', '.')) == null) {
                    return 'Insira um preço válido.';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _imageUrlController,
                decoration: const InputDecoration(
                  labelText: 'URL da Imagem (opcional)',
                  prefixIcon: Icon(Icons.image),
                ),
                keyboardType: TextInputType.url,
              ),
              const SizedBox(height: 16),
              DropdownButtonFormField<String>(
                value: _selectedCategory,
                decoration: const InputDecoration(
                  labelText: 'Categoria',
                  prefixIcon: Icon(Icons.category),
                ),
                items: ProductController.availableCategories.map<DropdownMenuItem<String>>((String category) {
                  return DropdownMenuItem<String>(
                    value: category,
                    child: Text(category),
                  );
                }).toList(),
                onChanged: (String? newValue) {
                  if (newValue != null) {
                    setState(() {
                      _selectedCategory = newValue;
                    });
                  }
                },
                validator: (String? value) {
                  if (value == null || value.isEmpty) {
                    return 'Selecione uma categoria.';
                  }
                  return null;
                },
              ),
              const SizedBox(height: 16),
              SwitchListTile(
                title: const Text('Requer Receita (Rx Only)'),
                secondary: const Icon(Icons.medical_information),
                value: _rxOnly,
                onChanged: (bool value) {
                  setState(() {
                    _rxOnly = value;
                  });
                },
              ),
              const SizedBox(height: 24),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: _saveProduct,
                  icon: const Icon(Icons.save),
                  label: Text(widget.product == null ? 'Adicionar Produto' : 'Salvar Alterações'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Cartão para exibição e gerenciamento de produtos na tela de administração.
class ProductManagementCard extends ConsumerWidget {
  final Product product;

  const ProductManagementCard({super.key, required this.product});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          children: <Widget>[
            ClipRRect(
              borderRadius: BorderRadius.circular(8.0),
              child: Image.network(
                product.imageUrl ?? 'https://www.gstatic.com/flutter-onestack-prototype/genui/example_1.jpg',
                width: 60,
                height: 60,
                fit: BoxFit.cover,
                errorBuilder: (BuildContext context, Object error, StackTrace? stackTrace) => Container(
                  width: 60,
                  height: 60,
                  color: Colors.grey[200],
                  child: const Icon(Icons.image_not_supported, color: Colors.grey),
                ),
              ),
            ),
            const SizedBox(width: 16.0),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: <Widget>[
                  Text(
                    product.name,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  Text(
                    'R\$ ${product.price.toStringAsFixed(2)}',
                    style: Theme.of(context).textTheme.titleSmall,
                  ),
                  if (product.rxOnly)
                    Padding(
                      padding: const EdgeInsets.only(top: 4.0),
                      child: Chip(
                        label: const Text('Com receita', style: TextStyle(fontSize: 10, color: Colors.white)),
                        backgroundColor: Colors.red[400],
                        materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      ),
                    ),
                ],
              ),
            ),
            IconButton(
              icon: const Icon(Icons.edit, color: Colors.blue),
              onPressed: () {
                Navigator.of(context).push(
                  MaterialPageRoute<void>(
                    builder: (BuildContext context) => ProductFormScreen(product: product),
                  ),
                );
              },
            ),
            IconButton(
              icon: const Icon(Icons.delete, color: Colors.red),
              onPressed: () {
                showDialog<void>(
                  context: context,
                  builder: (BuildContext dialogContext) => AlertDialog(
                    title: const Text('Confirmar Exclusão'),
                    content: Text('Tem certeza de que deseja excluir "${product.name}"?'),
                    actions: <Widget>[
                      TextButton(
                        onPressed: () => Navigator.of(dialogContext).pop(),
                        child: const Text('Cancelar'),
                      ),
                      ElevatedButton(
                        onPressed: () {
                          ref.read(productProvider.notifier).deleteProduct(product.id);
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(content: Text('${product.name} excluído.')),
                          );
                          Navigator.of(dialogContext).pop();
                        },
                        style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
                        child: const Text('Excluir'),
                      ),
                    ],
                  ),
                );
              },
            ),
          ],
        ),
      ),
    );
  }
}

/// Tela para gerenciar produtos (CRUD).
class ProductManagementScreen extends ConsumerWidget {
  const ProductManagementScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<Product> allProducts = ref.watch(productProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Gerenciar Produtos'),
      ),
      body: allProducts.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Icon(Icons.inventory_2_outlined, size: 90, color: Colors.grey),
                  const SizedBox(height: 24),
                  Text(
                    'Nenhum produto cadastrado ainda.',
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey[600]),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      Navigator.of(context).push(
                        MaterialPageRoute<void>(
                          builder: (BuildContext context) => const ProductFormScreen(),
                        ),
                      );
                    },
                    child: const Text('Adicionar Primeiro Produto'),
                  ),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16.0),
              itemCount: allProducts.length,
              itemBuilder: (BuildContext context, int index) {
                final Product product = allProducts[index];
                return ProductManagementCard(product: product);
              },
            ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          Navigator.of(context).push(
            MaterialPageRoute<void>(
              builder: (BuildContext context) => const ProductFormScreen(),
            ),
          );
        },
        child: const Icon(Icons.add),
      ),
    );
  }
}

/// Cartão de exibição para um único serviço.
class ServiceCard extends ConsumerWidget {
  final Service service;

  const ServiceCard({super.key, required this.service});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            Row(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: <Widget>[
                ClipRRect(
                  borderRadius: BorderRadius.circular(8.0),
                  child: Image.network(
                    service.imageUrl ?? 'https://www.gstatic.com/flutter-onestack-prototype/genui/example_1.jpg',
                    width: 80,
                    height: 80,
                    fit: BoxFit.cover,
                    errorBuilder: (BuildContext context, Object error, StackTrace? stackTrace) => Container(
                      width: 80,
                      height: 80,
                      color: Colors.grey[200],
                      child: const Icon(Icons.image_not_supported, color: Colors.grey),
                    ),
                  ),
                ),
                const SizedBox(width: 16.0),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: <Widget>[
                      Text(
                        service.name,
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                        maxLines: 2,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 4.0),
                      Text(
                        service.description,
                        style: Theme.of(context).textTheme.bodyMedium,
                        maxLines: 3,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: 8.0),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: <Widget>[
                          Text(
                            'R\$ ${service.price.toStringAsFixed(2)}',
                            style: Theme.of(context)
                                .textTheme.titleSmall?.copyWith(color: Colors.green[700], fontWeight: FontWeight.bold),
                          ),
                          Chip(
                            label: Text('${service.durationMinutes} min', style: const TextStyle(fontSize: 12, color: Colors.white)),
                            backgroundColor: Colors.blue[400],
                            materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16.0),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                icon: const Icon(Icons.calendar_month, size: 20),
                label: const Text('Agendar Serviço', style: TextStyle(fontSize: 16)),
                onPressed: () {
                  Navigator.of(context).push(
                    MaterialPageRoute<void>(
                      builder: (BuildContext context) => ReservationFormScreen(service: service),
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Tela para agendar um novo serviço.
class ReservationFormScreen extends ConsumerStatefulWidget {
  final Service service;

  const ReservationFormScreen({super.key, required this.service});

  @override
  ConsumerState<ReservationFormScreen> createState() => _ReservationFormScreenState();
}

class _ReservationFormScreenState extends ConsumerState<ReservationFormScreen> {
  final GlobalKey<FormState> _formKey = GlobalKey<FormState>();
  late DateTime _selectedDate;
  late TimeOfDay _selectedTime;
  final TextEditingController _notesController = TextEditingController();

  @override
  void initState() {
    super.initState();
    final DateTime now = DateTime.now();
    _selectedDate = DateTime(now.year, now.month, now.day);
    _selectedTime = TimeOfDay.fromDateTime(now.add(const Duration(hours: 1)));
  }

  @override
  void dispose() {
    _notesController.dispose();
    super.dispose();
  }

  Future<void> _pickDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime.now(),
      lastDate: DateTime.now().add(const Duration(days: 365)),
    );
    if (picked != null && picked != _selectedDate) {
      setState(() {
        _selectedDate = picked;
      });
    }
  }

  Future<void> _pickTime(BuildContext context) async {
    final TimeOfDay? picked = await showTimePicker(
      context: context,
      initialTime: _selectedTime,
    );
    if (picked != null && picked != _selectedTime) {
      setState(() {
        _selectedTime = picked;
      });
    }
  }

  void _submitReservation() {
    if (_formKey.currentState!.validate()) {
      final UserProfile? currentUser = ref.read(authProvider).currentUser;
      if (currentUser == null) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Você precisa estar logado para fazer uma reserva.')),
        );
        return;
      }

      final DateTime reservationDateTime = DateTime(
        _selectedDate.year,
        _selectedDate.month,
        _selectedDate.day,
        _selectedTime.hour,
        _selectedTime.minute,
      );

      if (reservationDateTime.isBefore(DateTime.now())) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Não é possível agendar um serviço para o passado.')),
        );
        return;
      }

      final Reservation newReservation = Reservation(
        id: 0, // ID will be generated by the controller
        userId: currentUser.id,
        userName: currentUser.name,
        serviceId: widget.service.id,
        serviceName: widget.service.name,
        reservationDateTime: reservationDateTime,
        notes: _notesController.text.trim().isEmpty ? null : _notesController.text.trim(),
      );

      ref.read(reservationProvider.notifier).makeReservation(newReservation);

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text('Reserva para "${widget.service.name}" agendada com sucesso!')),
      );
      Navigator.of(context).pop();
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Agendar Serviço'),
      ),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: <Widget>[
              Text(
                'Serviço: ${widget.service.name}',
                style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 8),
              Text(
                'Preço: R\$ ${widget.service.price.toStringAsFixed(2)} - Duração: ${widget.service.durationMinutes} minutos',
                style: Theme.of(context).textTheme.titleMedium,
              ),
              const SizedBox(height: 24),
              ListTile(
                leading: const Icon(Icons.calendar_today),
                title: Text('Data selecionada: ${DateFormat('dd/MM/yyyy').format(_selectedDate)}'),
                trailing: const Icon(Icons.edit),
                onTap: () => _pickDate(context),
              ),
              ListTile(
                leading: const Icon(Icons.access_time),
                title: Text('Hora selecionada: ${_selectedTime.format(context)}'),
                trailing: const Icon(Icons.edit),
                onTap: () => _pickTime(context),
              ),
              const SizedBox(height: 16),
              TextFormField(
                controller: _notesController,
                decoration: const InputDecoration(
                  labelText: 'Observações (opcional)',
                  prefixIcon: Icon(Icons.notes),
                ),
                maxLines: 3,
              ),
              const SizedBox(height: 32),
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: _submitReservation,
                  icon: const Icon(Icons.check_circle),
                  label: const Text('Confirmar Agendamento'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Cartão de exibição para uma reserva de usuário.
class ReservationUserCard extends ConsumerWidget {
  final Reservation reservation;

  const ReservationUserCard({super.key, required this.reservation});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final Service? service = ref.watch(serviceProvider.notifier).getServiceById(reservation.serviceId);

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            Row(
              children: <Widget>[
                Icon(reservation.status.icon, color: reservation.status.color),
                const SizedBox(width: 8),
                Text(
                  reservation.serviceName,
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
              ],
            ),
            const SizedBox(height: 8),
            Text(
              'Status: ${reservation.status.displayName}',
              style: Theme.of(context).textTheme.bodyMedium?.copyWith(color: reservation.status.color),
            ),
            const SizedBox(height: 4),
            Text(
              'Data: ${DateFormat('dd/MM/yyyy').format(reservation.reservationDateTime)} às ${DateFormat('HH:mm').format(reservation.reservationDateTime)}',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            if (service != null)
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: Text(
                  'Duração estimada: ${service.durationMinutes} minutos',
                  style: Theme.of(context).textTheme.bodySmall,
                ),
              ),
            if (reservation.notes != null && reservation.notes!.isNotEmpty) ...<Widget>[
              const SizedBox(height: 8),
              Text('Observações: ${reservation.notes}', style: Theme.of(context).textTheme.bodySmall),
            ],
            if (reservation.status == ReservationStatus.pending)
              Align(
                alignment: Alignment.bottomRight,
                child: TextButton.icon(
                  icon: const Icon(Icons.cancel, color: Colors.red),
                  label: const Text('Cancelar Reserva', style: TextStyle(color: Colors.red)),
                  onPressed: () {
                    showDialog<void>(
                      context: context,
                      builder: (BuildContext dialogContext) => AlertDialog(
                        title: const Text('Confirmar Cancelamento'),
                        content: const Text('Tem certeza de que deseja cancelar esta reserva?'),
                        actions: <Widget>[
                          TextButton(
                            onPressed: () => Navigator.of(dialogContext).pop(),
                            child: const Text('Não'),
                          ),
                          ElevatedButton(
                            onPressed: () {
                              ref.read(reservationProvider.notifier).cancelReservation(reservation.id);
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(content: Text('Reserva cancelada.')),
                              );
                              Navigator.of(dialogContext).pop();
                            },
                            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
                            child: const Text('Sim, Cancelar'),
                          ),
                        ],
                      ),
                    );
                  },
                ),
              ),
          ],
        ),
      ),
    );
  }
}

/// Tela para exibir as reservas do usuário logado.
class MyReservationsScreen extends ConsumerWidget {
  const MyReservationsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final UserProfile? currentUser = ref.watch(authProvider).currentUser;
    if (currentUser == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Minhas Reservas')),
        body: const Center(child: Text('Nenhum usuário logado.')),
      );
    }

    final List<Reservation> userReservations =
        ref.watch(reservationProvider.notifier).getReservationsForUser(currentUser.id);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Minhas Reservas'),
      ),
      body: userReservations.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Icon(Icons.calendar_month, size: 90, color: Colors.grey),
                  const SizedBox(height: 24),
                  Text(
                    'Você não tem nenhuma reserva ainda!',
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey[600]),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      Navigator.of(context).pop();
                      // Ideally navigate to the services tab
                    },
                    child: const Text('Agendar um Serviço'),
                  ),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16.0),
              itemCount: userReservations.length,
              itemBuilder: (BuildContext context, int index) {
                final Reservation reservation = userReservations[index];
                return ReservationUserCard(reservation: reservation);
              },
            ),
    );
  }
}

/// Cartão para exibição e gerenciamento de reservas na tela de administração.
class AdminReservationCard extends ConsumerWidget {
  final Reservation reservation;

  const AdminReservationCard({super.key, required this.reservation});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: <Widget>[
                Text(
                  'Serviço: ${reservation.serviceName}',
                  style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                ),
                IconButton(
                  icon: const Icon(Icons.delete, color: Colors.red),
                  onPressed: () {
                    showDialog<void>(
                      context: context,
                      builder: (BuildContext dialogContext) => AlertDialog(
                        title: const Text('Confirmar Exclusão'),
                        content: Text('Tem certeza de que deseja excluir a reserva para "${reservation.serviceName}" de "${reservation.userName}"?'),
                        actions: <Widget>[
                          TextButton(
                            onPressed: () => Navigator.of(dialogContext).pop(),
                            child: const Text('Cancelar'),
                          ),
                          ElevatedButton(
                            onPressed: () {
                              ref.read(reservationProvider.notifier).updateReservationStatus(reservation.id, ReservationStatus.cancelled); // Mark as cancelled instead of deleting
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(content: Text('Reserva cancelada pelo admin.')),
                              );
                              Navigator.of(dialogContext).pop();
                            },
                            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
                            child: const Text('Excluir'),
                          ),
                        ],
                      ),
                    );
                  },
                ),
              ],
            ),
            const SizedBox(height: 4),
            Text('Cliente: ${reservation.userName}', style: Theme.of(context).textTheme.bodyMedium),
            Text(
              'Data/Hora: ${DateFormat('dd/MM/yyyy HH:mm').format(reservation.reservationDateTime)}',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
            if (reservation.notes != null && reservation.notes!.isNotEmpty)
              Text('Notas: ${reservation.notes}', style: Theme.of(context).textTheme.bodySmall),
            const SizedBox(height: 8),
            Row(
              children: <Widget>[
                Text('Status:', style: Theme.of(context).textTheme.bodyMedium),
                const SizedBox(width: 8),
                DropdownButton<ReservationStatus>(
                  value: reservation.status,
                  onChanged: (ReservationStatus? newStatus) {
                    if (newStatus != null) {
                      ref.read(reservationProvider.notifier).updateReservationStatus(reservation.id, newStatus);
                      ScaffoldMessenger.of(context).showSnackBar(
                        SnackBar(content: Text('Status da reserva atualizado para ${newStatus.displayName}')),
                      );
                    }
                  },
                  items: ReservationStatus.values.map<DropdownMenuItem<ReservationStatus>>((ReservationStatus status) {
                    return DropdownMenuItem<ReservationStatus>(
                      value: status,
                      child: Row(
                        children: <Widget>[
                          Icon(status.icon, color: status.color, size: 20),
                          const SizedBox(width: 8),
                          Text(status.displayName),
                        ],
                      ),
                    );
                  }).toList(),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

/// Tela para gerenciar todas as reservas (para administradores).
class AdminReservationsScreen extends ConsumerWidget {
  const AdminReservationsScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<Reservation> allReservations = ref.watch(reservationProvider);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Gerenciar Reservas'),
      ),
      body: allReservations.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: <Widget>[
                  const Icon(Icons.event_busy, size: 90, color: Colors.grey),
                  const SizedBox(height: 24),
                  Text(
                    'Nenhuma reserva agendada ainda.',
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey[600]),
                  ),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16.0),
              itemCount: allReservations.length,
              itemBuilder: (BuildContext context, int index) {
                final Reservation reservation = allReservations[index];
                return AdminReservationCard(reservation: reservation);
              },
            ),
    );
  }
}

/// Tela principal da biblioteca do aplicativo, exibindo produtos por categoria e informações do usuário.
class AppLibraryScreen extends ConsumerStatefulWidget {
  /// Construtor para AppLibraryScreen.
  const AppLibraryScreen({super.key});

  @override
  ConsumerState<AppLibraryScreen> createState() => _AppLibraryScreenState();
}

class _AppLibraryScreenState extends ConsumerState<AppLibraryScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  static final List<String> _productCategories = ProductController.availableCategories;
  static const String _servicesTab = 'Serviços';
  // Declare _allTabs as late final and initialize it in initState
  late final List<String> _allTabs;

  @override
  void initState() {
    super.initState();
    // Initialize _allTabs here
    _allTabs = <String>[..._productCategories, _servicesTab];
    _tabController = TabController(length: _allTabs.length, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider);
    final UserProfile? currentUser = authState.currentUser;
    final List<Product> allProducts = ref.watch(productProvider);
    final List<Service> allServices = ref.watch(serviceProvider);
    final int cartItemCount = ref.watch(cartProvider.notifier).getTotalQuantity();

    if (currentUser == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Erro')),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Icons.error_outline, size: 60, color: Colors.red),
              const SizedBox(height: 16),
              Text('Nenhum usuário logado.', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop();
                },
                child: const Text('Voltar'),
              ),
            ],
          ),
        ),
      );
    }

    final bool isAdmin = currentUser.email == AuthController._fixedUserEmail;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Biblioteca do Aplicativo'),
        actions: <Widget>[
          Stack(
            children: <Widget>[
              IconButton(
                icon: const Icon(Icons.shopping_cart),
                onPressed: () {
                  Navigator.of(context).push(
                    MaterialPageRoute<void>(
                      builder: (BuildContext context) => const CartScreen(),
                    ),
                  );
                },
              ),
              if (cartItemCount > 0)
                Positioned(
                  right: 8,
                  top: 8,
                  child: Container(
                    padding: const EdgeInsets.all(2),
                    decoration: BoxDecoration(
                      color: Colors.red,
                      borderRadius: BorderRadius.circular(10),
                    ),
                    constraints: const BoxConstraints(
                      minWidth: 16,
                      minHeight: 16,
                    ),
                    child: Text(
                      '$cartItemCount',
                      style: const TextStyle(
                        color: Colors.white,
                        fontSize: 10,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
            ],
          ),
          IconButton(
            icon: const Icon(Icons.favorite),
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute<void>(
                  builder: (BuildContext context) => const FavoritesScreen(),
                ),
              );
            },
            tooltip: 'Meus Favoritos',
          ),
          IconButton(
            icon: const Icon(Icons.calendar_month),
            onPressed: () {
              Navigator.of(context).push(
                MaterialPageRoute<void>(
                  builder: (BuildContext context) => const MyReservationsScreen(),
                ),
              );
            },
            tooltip: 'Minhas Reservas',
          ),
        ],
        bottom: TabBar(
          controller: _tabController,
          tabs: _allTabs.map<Widget>((String category) => Tab(text: category)).toList(),
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          indicatorColor: Colors.white,
          isScrollable: true,
        ),
      ),
      drawer: Drawer(
        child: ListView(
          padding: EdgeInsets.zero,
          children: <Widget>[
            DrawerHeader(
              decoration: BoxDecoration(
                color: Theme.of(context).primaryColor,
              ),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                mainAxisAlignment: MainAxisAlignment.end,
                children: <Widget>[
                  Text(
                    currentUser.name,
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(color: Colors.white),
                  ),
                  Text(
                    currentUser.email,
                    style: Theme.of(context).textTheme.titleMedium?.copyWith(color: Colors.white70),
                  ),
                ],
              ),
            ),
            ListTile(
              leading: const Icon(Icons.home),
              title: const Text('Página Principal'),
              onTap: () {
                Navigator.of(context).pop(); // Close the drawer
                Navigator.of(context).pushReplacement(
                  MaterialPageRoute<void>(
                    builder: (BuildContext context) => const HomeScreen(),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.shopping_cart),
              title: const Text('Meu Carrinho'),
              onTap: () {
                Navigator.of(context).pop(); // Close the drawer
                Navigator.of(context).push(
                  MaterialPageRoute<void>(
                    builder: (BuildContext context) => const CartScreen(),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.favorite),
              title: const Text('Meus Favoritos'),
              onTap: () {
                Navigator.of(context).pop(); // Close the drawer
                Navigator.of(context).push(
                  MaterialPageRoute<void>(
                    builder: (BuildContext context) => const FavoritesScreen(),
                  ),
                );
              },
            ),
            ListTile(
              leading: const Icon(Icons.calendar_month),
              title: const Text('Minhas Reservas'),
              onTap: () {
                Navigator.of(context).pop(); // Close the drawer
                Navigator.of(context).push(
                  MaterialPageRoute<void>(
                    builder: (BuildContext context) => const MyReservationsScreen(),
                  ),
                );
              },
            ),
            if (isAdmin)
              ListTile(
                leading: const Icon(Icons.admin_panel_settings),
                title: const Text('Gerenciar Produtos'),
                onTap: () {
                  Navigator.of(context).pop(); // Close the drawer
                  Navigator.of(context).push(
                    MaterialPageRoute<void>(
                      builder: (BuildContext context) => const ProductManagementScreen(),
                    ),
                  );
                },
              ),
            if (isAdmin)
              ListTile(
                leading: const Icon(Icons.event_note),
                title: const Text('Gerenciar Reservas'),
                onTap: () {
                  Navigator.of(context).pop(); // Close the drawer
                  Navigator.of(context).push(
                    MaterialPageRoute<void>(
                      builder: (BuildContext context) => const AdminReservationsScreen(),
                    ),
                  );
                },
              ),
            const Divider(),
            ListTile(
              leading: const Icon(Icons.logout, color: Colors.red),
              title: const Text('Sair', style: TextStyle(color: Colors.red)),
              onTap: () {
                ref.read(authProvider.notifier).logout();
                Navigator.of(context).pop(); // Close the drawer
              },
            ),
          ],
        ),
      ),
      body: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Card(
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: <Widget>[
                    Text(
                      'Informações do Usuário:',
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),
                    Row(
                      children: <Widget>[
                        const Icon(Icons.person, color: Colors.pinkAccent),
                        const SizedBox(width: 8),
                        Text('Nome: ${currentUser.name}', style: Theme.of(context).textTheme.titleMedium),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: <Widget>[
                        const Icon(Icons.badge, color: Colors.pinkAccent),
                        const SizedBox(width: 8),
                        Text('ID: ${currentUser.id}', style: Theme.of(context).textTheme.titleMedium),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: <Widget>[
                        const Icon(Icons.email, color: Colors.pinkAccent),
                        const SizedBox(width: 8),
                        Text('Email: ${currentUser.email}', style: Theme.of(context).textTheme.titleMedium),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: _allTabs.map<Widget>((String tabName) {
                if (tabName == _servicesTab) {
                  if (allServices.isEmpty) {
                    return Center(
                      child: Text('Nenhum serviço disponível.', style: Theme.of(context).textTheme.titleMedium),
                    );
                  }
                  return ListView.builder(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                    itemCount: allServices.length,
                    itemBuilder: (BuildContext context, int index) {
                      final Service service = allServices[index];
                      return ServiceCard(service: service);
                    },
                  );
                } else {
                  final List<Product> categoryProducts = allProducts.where((Product p) => p.category == tabName).toList();
                  if (categoryProducts.isEmpty) {
                    return Center(
                      child: Text('Nenhum item encontrado na categoria "$tabName".', style: Theme.of(context).textTheme.titleMedium),
                    );
                  }
                  return ListView.builder(
                    padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                    itemCount: categoryProducts.length,
                    itemBuilder: (BuildContext context, int index) {
                      final Product product = categoryProducts[index];
                      return ProductCard(product: product);
                    },
                  );
                }
              }).toList(),
            ),
          ),
        ],
      ),
    );
  }
}

/// Tela principal exibida após o login bem-sucedido.
class HomeScreen extends ConsumerWidget {
  /// Construtor para HomeScreen.
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AuthState authState = ref.watch(authProvider);
    final UserProfile? currentUser = authState.currentUser;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Página Principal'),
        actions: <Widget>[
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () {
              ref.read(authProvider.notifier).logout();
            },
            tooltip: 'Sair',
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const Icon(Icons.check_circle_outline, size: 90, color: Colors.green),
            const SizedBox(height: 32.0),
            Text(
              'Você está logado!',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 12.0),
            Text(
              'Bem-vindo de volta, ${currentUser?.name ?? 'usuário'}!',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 32.0),
            ElevatedButton.icon(
              onPressed: () {
                Navigator.of(context).push(
                  MaterialPageRoute<void>(
                    builder: (BuildContext context) => const AppLibraryScreen(),
                  ),
                );
              },
              icon: const Icon(Icons.apps),
              label: const Text('Ir para o App'),
            ),
            const SizedBox(height: 16.0),
            TextButton(
              onPressed: () {
                ref.read(authProvider.notifier).logout();
              },
              child: const Text('Sair da Conta'),
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget que verifica o estado de autenticação e exibe a tela apropriada.
class AuthChecker extends ConsumerWidget {
  /// Construtor para AuthChecker.
  const AuthChecker({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AuthState authState = ref.watch(authProvider);

    if (authState.isAuthed) {
      return const HomeScreen();
    } else {
      return const LoginScreen();
    }
  }
}

/// O widget raiz da aplicação Flutter.
class MyApp extends StatelessWidget {
  /// Construtor para MyApp.
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'VetApp',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        primarySwatch: Colors.pink,
        visualDensity: VisualDensity.adaptivePlatformDensity,
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.pinkAccent,
          foregroundColor: Colors.white,
          centerTitle: true,
          titleTextStyle: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.pinkAccent,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
            textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide.none,
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(color: Colors.pinkAccent, width: 2),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(color: Colors.pink, width: 2),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(color: Colors.pink, width: 2),
          ),
          filled: true,
          fillColor: Colors.pink.withOpacity(0.08),
          contentPadding: const EdgeInsets.symmetric(vertical: 18.0, horizontal: 16.0),
          labelStyle: TextStyle(color: Colors.grey[700]),
          hintStyle: TextStyle(color: Colors.grey[400]),
          prefixIconColor: Colors.pinkAccent,
          errorStyle: const TextStyle(color: Colors.pink, fontSize: 14),
        ),
        textTheme: const TextTheme(
          headlineMedium: TextStyle(color: Colors.black87),
          headlineSmall: TextStyle(color: Colors.black87),
          titleMedium: TextStyle(color: Colors.black54),
          titleSmall: TextStyle(color: Colors.black87),
          titleLarge: TextStyle(color: Colors.black87),
          bodyMedium: TextStyle(color: Colors.black54),
        ),
      ),
      home: const AuthChecker(),
    );
  }
}

/// Função principal que inicia a aplicação Flutter.
void main() {
  runApp(
    const ProviderScope(
      child: MyApp(),
    ),
  );
}
