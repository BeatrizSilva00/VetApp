import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// ------------------------------
// Data Models
// ------------------------------

class UserProfile {
  final int id;
  final String name;
  final String email;

  UserProfile({required this.id, required this.name, required this.email});
}

class Product {
  final int id;
  String name;
  String description;
  double price;
  bool rxOnly; // precisa de receita?
  String? imageUrl;
  final String category; // New: e.g., 'Remédios', 'Rações', 'Brinquedos'

  Product({
    required this.id,
    required this.name,
    required this.description,
    required this.price,
    this.rxOnly = false,
    this.imageUrl,
    required this.category,
  });

  Product copyWith({
    int? id,
    String? name,
    String? description,
    double? price,
    bool? rxOnly,
    String? imageUrl,
    String? category,
  }) =>
      Product(
        id: id ?? this.id,
        name: name ?? this.name,
        description: description ?? this.description,
        price: price ?? this.price,
        rxOnly: rxOnly ?? this.rxOnly,
        imageUrl: imageUrl ?? this.imageUrl,
        category: category ?? this.category,
      );
}

class AuthState {
  final bool isLoading;
  final bool isAuthed;
  final String? error; // General error message for auth operations
  final bool? isEmailError; // True if 'error' is specific to email, false if general/password-related
  final UserProfile? currentUser; // Stores the profile of the currently logged-in user

  const AuthState({
    this.isLoading = false,
    this.isAuthed = false,
    this.error,
    this.isEmailError,
    this.currentUser,
  });

  AuthState copyWith({
    bool? isLoading,
    bool? isAuthed,
    String? error, // Nullable to explicitly clear
    bool? isEmailError, // Nullable to explicitly clear or change
    UserProfile? currentUser, // Nullable to explicitly clear or change
  }) =>
      AuthState(
        isLoading: isLoading ?? this.isLoading,
        isAuthed: isAuthed ?? this.isAuthed,
        error: error,
        isEmailError: isEmailError,
        currentUser: currentUser,
      );
}

// ------------------------------
// State Notifiers (Controllers)
// ------------------------------

class AuthController extends StateNotifier<AuthState> {
  AuthController() : super(const AuthState());

  static const String _fixedUser = 'admin@vet.com';
  static const String _fixedPass = '123456';

  // Store registered users (email -> password)
  final Map<String, String> _registeredUsers = {};

  Future<void> login(String user, String pass) async {
    state = state.copyWith(isLoading: true, error: null, isEmailError: null, currentUser: null); // Clear previous errors and user
    await Future.delayed(const Duration(milliseconds: 800)); // mock delay

    bool isAuthenticated = false;
    UserProfile? userProfile;

    // Check fixed admin user
    if (user == _fixedUser && pass == _fixedPass) {
      isAuthenticated = true;
      userProfile = UserProfile(id: 1, name: 'Admin Vet', email: user);
    }
    // Check registered users
    else if (_registeredUsers.containsKey(user) && _registeredUsers[user] == pass) {
      isAuthenticated = true;
      // Generate a simple user profile for registered users
      userProfile = UserProfile(id: user.hashCode.abs(), name: 'Usuário ${user.split('@').first}', email: user);
    }

    if (isAuthenticated) {
      state = state.copyWith(
          isAuthed: true, isLoading: false, error: null, isEmailError: null, currentUser: userProfile);
    } else {
      // As per prompt "Mostre o erro na senha.", this general error will be shown in the password field.
      state = state.copyWith(
          isAuthed: false, isLoading: false, error: 'Cadastro inválido.', isEmailError: false, currentUser: null);
    }
  }

  Future<void> register(String user, String pass) async {
    state = state.copyWith(isLoading: true, error: null, isEmailError: null, currentUser: null); // Clear previous errors
    await Future.delayed(const Duration(milliseconds: 1200)); // mock delay for registration

    // Check if user already exists (admin or a previously registered user)
    if (_registeredUsers.containsKey(user) || user == _fixedUser) {
      // This is an email-specific error
      state = state.copyWith(isLoading: false, error: 'Este email já está cadastrado.', isEmailError: true);
      return;
    }

    // Register user
    _registeredUsers[user] = pass;
    // Do not auto-login after registration, just clear error and stop loading.
    state = state.copyWith(isLoading: false, error: null, isEmailError: null);
  }

  void logout() {
    state = const AuthState(); // Reset to initial unauthenticated state
  }
}

class ProductController extends StateNotifier<List<Product>> {
  ProductController() : super(_initialProducts); // Initialize with dummy data

  static final List<Product> _initialProducts = [
    Product(
      id: 101,
      name: 'Anti-pulgas PetGuard',
      description: 'Proteção eficaz contra pulgas e carrapatos por 3 meses.',
      price: 89.90,
      rxOnly: false,
      imageUrl: 'https://images.tcdn.com.br/img/img_prod/469080/nexgard_antipulgas_caes_p_2kg_a_4kg_1_comprimido_boehringer_432_1_13f003e9c4b9fe1c31c67d5f5fb8f05f.png',
      category: 'Remédios',
    ),
    Product(
      id: 102,
      name: 'Antibiótico AmoxPet 250mg',
      description: 'Antibiótico de amplo espectro para infecções bacterianas.',
      price: 65.50,
      rxOnly: true,
      imageUrl: 'https://agrosolo.fbitsstatic.net/img/p/antibiotico-doxiciclina-doxitec-200mg-para-caes-16-comprimidos-89123/284689.jpg?w=700&h=700&v=202504291638',
      category: 'Remédios',
    ),
    Product(
      id: 103,
      name: 'Vermífugo CanineCare',
      description: 'Combate vermes intestinais em cães e gatos.',
      price: 35.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT8DWzbB9P9VERuidx9GwdwebtgsszUawJ9lw&s',
      category: 'Remédios',
    ),
    Product(
      id: 201,
      name: 'Ração Premium DogFit',
      description: 'Alimento completo e balanceado para cães adultos.',
      price: 120.00,
      rxOnly: false,
      imageUrl: 'https://www.petlove.com.br/images/products/273209/product/31027529907_Ra%C3%A7%C3%A3o_Seca_Dogfit_Gourmet_Carne_e_Vegetais_para_C%C3%A3es_Adultos_Porte_Pequeno_e_M%C3%A9dio_%281%29.jpg?1694521363',
      category: 'Rações',
    ),
    Product(
      id: 202,
      name: 'Ração Hipoalergênica CatHealthy',
      description: 'Fórmula especial para gatos com sensibilidade alimentar.',
      price: 95.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTowFVywEowD88opffFHbChTD67XcEtLfv1Ug&s',
      category: 'Rações',
    ),
    Product(
      id: 203,
      name: 'Petisco Dental Bites',
      description: 'Ajuda a reduzir o tártaro e manter a higiene bucal.',
      price: 25.00,
      rxOnly: false,
      imageUrl: 'https://http2.mlstatic.com/D_NQ_NP_605948-MLB47205197255_082021-O.webp',
      category: 'Rações',
    ),
    Product(
      id: 301,
      name: 'Bola Interativa PetPlay',
      description: 'Bola com dispenser de petiscos, estimula o raciocínio.',
      price: 45.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR3KF-xAehT3_BC-l6WPI866EPVZFkCwAzdtw&s',
      category: 'Brinquedos',
    ),
    Product(
      id: 302,
      name: 'Arranhador para Gatos Tower',
      description: 'Torre de arranhar com várias plataformas e brinquedos pendurados.',
      price: 180.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT18aYym3TgRzV6I58fZJ0T6cs_BfiVL1OVmQ&s',
      category: 'Brinquedos',
    ),
    Product(
      id: 303,
      name: 'Corda de Roer para Cães',
      description: 'Brinquedo resistente para cães que adoram mastigar.',
      price: 30.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRbsbIIMKHjDlNv4hP7ZSH0a9-ZQ5xGslEbPw&s',
      category: 'Brinquedos',
    ),
  ];

  List<Product> getProductsByCategory(String category) {
    return state.where((Product product) => product.category == category).toList();
  }
}

// ------------------------------
// Riverpod Providers
// ------------------------------

final authProvider = StateNotifierProvider<AuthController, AuthState>((ref) {
  return AuthController();
});

final productProvider = StateNotifierProvider<ProductController, List<Product>>((ref) {
  return ProductController();
});

// ------------------------------
// UI Widgets
// ------------------------------

class RegistrationSuccessScreen extends StatelessWidget {
  final String registeredEmail;

  const RegistrationSuccessScreen({super.key, required this.registeredEmail});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Cadastro Concluído'),
        automaticallyImplyLeading: false, 
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Icons.check_circle_outline, size: 90, color: Colors.green),
              const SizedBox(height: 32.0),
              Text(
                'Parabéns!',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.green,
                      fontWeight: FontWeight.bold,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16.0),
              Text(
                'Sua conta para "$registeredEmail" foi criada com sucesso.',
                style: Theme.of(context).textTheme.titleMedium,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32.0),
              ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop();
                },
                child: const Text('Voltar para o Login'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class LoginScreen extends ConsumerStatefulWidget {
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState();
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  String? _emailLocalError;
  String? _passwordLocalError;

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider);

    String? emailAuthError;
    String? passwordAuthError;

    if (authState.error != null && !authState.isLoading && !authState.isAuthed) {
      if (authState.isEmailError == true) {
        emailAuthError = authState.error;
      } else if (authState.isEmailError == false) {
        passwordAuthError = authState.error;
      }
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Entrar no Sistema'),
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Icons.pets, size: 90, color: Colors.pinkAccent),
              const SizedBox(height: 32.0),
              Text(
                'Bem-vindo ao VetApp',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.pinkAccent,
                      fontWeight: FontWeight.bold,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32.0),
              TextField(
                controller: _emailController,
                onChanged: (_) {
                  if (_emailLocalError != null) {
                    setState(() => _emailLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Email',
                  prefixIcon: const Icon(Icons.email),
                  hintText: 'admin@vet.com',
                  errorText: _emailLocalError ?? emailAuthError,
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16.0),
              TextField(
                controller: _passwordController,
                onChanged: (_) {
                  if (_passwordLocalError != null) {
                    setState(() => _passwordLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Senha',
                  prefixIcon: const Icon(Icons.lock),
                  hintText: '123456',
                  errorText: _passwordLocalError ?? passwordAuthError,
                ),
                obscureText: true,
              ),
              const SizedBox(height: 32.0),
              if (authState.isLoading)
                const CircularProgressIndicator()
              else
                ElevatedButton(
                  onPressed: () {
                    final String email = _emailController.text.trim();
                    final String password = _passwordController.text.trim();

                    bool hasLocalError = false;
                    String? tempEmailError;
                    String? tempPasswordError;

                    if (email.isEmpty) {
                      tempEmailError = 'Por favor, preencha seu email.';
                      hasLocalError = true;
                    }
                    if (password.isEmpty) {
                      tempPasswordError = 'Por favor, preencha sua senha.';
                      hasLocalError = true;
                    }

                    setState(() {
                      _emailLocalError = tempEmailError;
                      _passwordLocalError = tempPasswordError;
                    });

                    if (hasLocalError) {
                      return;
                    }

                    // Clear any auth-related error from previous attempts before login
                    ref.read(authProvider.notifier).state = authState.copyWith(error: null, isEmailError: null);
                    ref.read(authProvider.notifier).login(email, password);
                  },
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size.fromHeight(50), // Make button full width
                  ),
                  child: const Text('Login'),
                ),
              const SizedBox(height: 20.0), // Space before registration button
              TextButton(
                onPressed: () {
                  // Clear any previous auth errors before navigating to register
                  ref.read(authProvider.notifier).state =
                      ref.read(authProvider.notifier).state.copyWith(error: null, isEmailError: null);
                  Navigator.of(context).push(
                    MaterialPageRoute<void>(
                      builder: (BuildContext context) => const RegisterScreen(),
                    ),
                  );
                },
                child: const Text(
                  'Não tem uma conta? Cadastre-se aqui!',
                  style: TextStyle(color: Colors.pinkAccent, fontSize: 16),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

class RegisterScreen extends ConsumerStatefulWidget {
  const RegisterScreen({super.key});

  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState();
}

class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();
  String? _emailLocalError; // Local state for empty email field validation error
  String? _passwordLocalError; // Local state for empty password field validation error

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider);

    String? emailAuthError;
    String? passwordAuthError;

    if (authState.error != null && !authState.isLoading) {
      if (authState.isEmailError == true) {
        // 'Este email já está cadastrado.'
        emailAuthError = authState.error;
      } else if (authState.isEmailError == false) {
        // Hypothetical future password registration error
        passwordAuthError = authState.error;
      }
    }

    // Listen for auth state changes specifically for registration success/error
    ref.listen<AuthState>(authProvider, (AuthState? previous, AuthState current) {
      // If registration was attempted (previous was loading) and it's no longer loading,
      // and there's no error, then registration was successful.
      if (previous?.isLoading == true && !current.isLoading && current.error == null) {
        // Replace RegisterScreen with RegistrationSuccessScreen
        Navigator.of(context).pushReplacement(
          MaterialPageRoute<void>(
            builder: (BuildContext context) => RegistrationSuccessScreen(registeredEmail: _emailController.text),
          ),
        );
      }
    });

    return Scaffold(
      appBar: AppBar(
        title: const Text('Cadastro de Usuário'),
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Icons.person_add, size: 90, color: Colors.pinkAccent),
              const SizedBox(height: 32.0),
              Text(
                'Criar Nova Conta',
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.pinkAccent,
                      fontWeight: FontWeight.bold,
                    ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32.0),
              TextField(
                controller: _emailController,
                onChanged: (_) {
                  if (_emailLocalError != null) {
                    setState(() => _emailLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Email',
                  prefixIcon: const Icon(Icons.email),
                  hintText: 'seu.email@exemplo.com',
                  errorText: _emailLocalError ?? emailAuthError,
                ),
                keyboardType: TextInputType.emailAddress,
              ),
              const SizedBox(height: 16.0),
              TextField(
                controller: _passwordController,
                onChanged: (_) {
                  if (_passwordLocalError != null) {
                    setState(() => _passwordLocalError = null);
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Senha',
                  prefixIcon: const Icon(Icons.lock),
                  hintText: '********',
                  errorText: _passwordLocalError ?? passwordAuthError,
                ),
                obscureText: true,
              ),
              const SizedBox(height: 32.0),
              if (authState.isLoading)
                const CircularProgressIndicator()
              else
                ElevatedButton(
                  onPressed: () {
                    final String email = _emailController.text.trim();
                    final String password = _passwordController.text.trim();

                    bool hasLocalError = false;
                    String? tempEmailError;
                    String? tempPasswordError;

                    if (email.isEmpty) {
                      tempEmailError = 'Por favor, preencha seu email para cadastro.';
                      hasLocalError = true;
                    }
                    if (password.isEmpty) {
                      tempPasswordError = 'Por favor, preencha sua senha para cadastro.';
                      hasLocalError = true;
                    }

                    setState(() {
                      _emailLocalError = tempEmailError;
                      _passwordLocalError = tempPasswordError;
                    });

                    if (hasLocalError) {
                      return;
                    }

                    // Clear any auth-related error from previous attempts before register
                    ref.read(authProvider.notifier).state = authState.copyWith(error: null, isEmailError: null);
                    ref.read(authProvider.notifier).register(email, password);
                  },
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size.fromHeight(50),
                  ),
                  child: const Text('Cadastrar'),
                ),
            ],
          ),
        ),
      ),
    );
  }
}

class ProductCard extends StatelessWidget {
  final Product product;

  const ProductCard({super.key, required this.product});

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0),
      elevation: 2,
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: <Widget>[
            ClipRRect(
              borderRadius: BorderRadius.circular(8.0),
              child: Image.network(
                product.imageUrl ?? 'https://www.gstatic.com/flutter-onestack-prototype/genui/example_1.jpg',
                width: 80,
                height: 80,
                fit: BoxFit.cover,
                errorBuilder: (BuildContext context, Object error, StackTrace? stackTrace) => Container(
                  width: 80,
                  height: 80,
                  color: Colors.grey[200],
                  child: const Icon(Icons.image_not_supported, color: Colors.grey),
                ),
              ),
            ),
            const SizedBox(width: 16.0),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: <Widget>[
                  Text(
                    product.name,
                    style:
                        Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 4.0),
                  Text(
                    product.description,
                    style: Theme.of(context).textTheme.bodyMedium,
                    maxLines: 3,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8.0),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: <Widget>[
                      Text(
                        'R\$ ${product.price.toStringAsFixed(2)}',
                        style: Theme.of(context)
                            .textTheme.titleSmall?.copyWith(color: Colors.green[700], fontWeight: FontWeight.bold),
                      ),
                      if (product.rxOnly)
                        Chip(
                          label: const Text('Com receita', style: TextStyle(fontSize: 12, color: Colors.white)),
                          backgroundColor: Colors.red[400],
                          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
                        ),
                    ],
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class AppLibraryScreen extends ConsumerStatefulWidget {
  const AppLibraryScreen({super.key});

  @override
  ConsumerState<AppLibraryScreen> createState() => _AppLibraryScreenState();
}

class _AppLibraryScreenState extends ConsumerState<AppLibraryScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController;
  static const List<String> _productCategories = ['Remédios', 'Rações', 'Brinquedos'];

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: _productCategories.length, vsync: this);
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider);
    final UserProfile? currentUser = authState.currentUser;
    final List<Product> allProducts = ref.watch(productProvider);

    if (currentUser == null) {
      // This case should ideally not be reached if navigation is guarded by AuthChecker.
      return Scaffold(
        appBar: AppBar(title: const Text('Erro')),
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              const Icon(Icons.error_outline, size: 60, color: Colors.red),
              const SizedBox(height: 16),
              Text('Nenhum usuário logado.', style: Theme.of(context).textTheme.titleMedium),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop(); // Go back to the previous screen (Login or Home)
                },
                child: const Text('Voltar'),
              ),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Biblioteca do Aplicativo'),
        bottom: TabBar(
          controller: _tabController,
          tabs: _productCategories.map<Widget>((String category) => Tab(text: category)).toList(),
          labelColor: Colors.white,
          unselectedLabelColor: Colors.white70,
          indicatorColor: Colors.white,
        ),
      ),
      body: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Card(
              elevation: 4,
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: <Widget>[
                    Text(
                      'Informações do Usuário:',
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                    ),
                    const SizedBox(height: 8),
                    Row(
                      children: <Widget>[
                        const Icon(Icons.person, color: Colors.pinkAccent),
                        const SizedBox(width: 8),
                        Text('Nome: ${currentUser.name}', style: Theme.of(context).textTheme.titleMedium),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: <Widget>[
                        const Icon(Icons.badge, color: Colors.pinkAccent),
                        const SizedBox(width: 8),
                        Text('ID: ${currentUser.id}', style: Theme.of(context).textTheme.titleMedium),
                      ],
                    ),
                    const SizedBox(height: 4),
                    Row(
                      children: <Widget>[
                        const Icon(Icons.email, color: Colors.pinkAccent),
                        const SizedBox(width: 8),
                        Text('Email: ${currentUser.email}', style: Theme.of(context).textTheme.titleMedium),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: _productCategories.map<Widget>((String category) {
                final List<Product> categoryProducts = allProducts.where((Product p) => p.category == category).toList();
                if (categoryProducts.isEmpty) {
                  return Center(
                    child: Text('Nenhum item encontrado na categoria "$category".', style: Theme.of(context).textTheme.titleMedium),
                  );
                }
                return ListView.builder(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
                  itemCount: categoryProducts.length,
                  itemBuilder: (BuildContext context, int index) {
                    final Product product = categoryProducts[index];
                    return ProductCard(product: product);
                  },
                );
              }).toList(),
            ),
          ),
        ],
      ),
    );
  }
}

class HomeScreen extends ConsumerWidget {
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AuthState authState = ref.watch(authProvider);
    final UserProfile? currentUser = authState.currentUser;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Página Principal'),
        actions: <Widget>[
          IconButton(
            icon: const Icon(Icons.logout),
            onPressed: () {
              ref.read(authProvider.notifier).logout();
            },
            tooltip: 'Sair',
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: <Widget>[
            const Icon(Icons.check_circle_outline, size: 90, color: Colors.green),
            const SizedBox(height: 32.0),
            Text(
              'Você está logado!',
              style: Theme.of(context).textTheme.headlineSmall,
            ),
            const SizedBox(height: 12.0),
            Text(
              'Bem-vindo de volta, ${currentUser?.name ?? 'usuário'}!',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 32.0),
            ElevatedButton.icon(
              onPressed: () {
                // Navigate to AppLibraryScreen
                Navigator.of(context).push(
                  MaterialPageRoute<void>(
                    builder: (BuildContext context) => const AppLibraryScreen(),
                  ),
                );
              },
              icon: const Icon(Icons.apps), // Changed icon
              label: const Text('Ir para o App'), // Changed text
            ),
            const SizedBox(height: 16.0), // Added space for logout
            TextButton(
              // Keep a logout option
              onPressed: () {
                ref.read(authProvider.notifier).logout();
              },
              child: const Text('Sair da Conta'),
            ),
          ],
        ),
      ),
    );
  }
}

class AuthChecker extends ConsumerWidget {
  const AuthChecker({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AuthState authState = ref.watch(authProvider);

    if (authState.isAuthed) {
      return const HomeScreen();
    } else {
      return const LoginScreen();
    }
  }
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'VetApp',
      debugShowCheckedModeBanner: false,
      theme: ThemeData(
        primarySwatch: Colors.pink,
        visualDensity: VisualDensity.adaptivePlatformDensity,
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.pinkAccent,
          foregroundColor: Colors.white,
          centerTitle: true,
          titleTextStyle: TextStyle(
            fontSize: 20,
            fontWeight: FontWeight.bold,
            color: Colors.white,
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.pinkAccent,
            foregroundColor: Colors.white,
            padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
            textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10),
            ),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: BorderSide.none,
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(color: Colors.pinkAccent, width: 2),
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(color: Colors.pink, width: 2),
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10),
            borderSide: const BorderSide(color: Colors.pink, width: 2),
          ),
          filled: true,
          fillColor: Colors.pink.withOpacity(0.08),
          contentPadding: const EdgeInsets.symmetric(vertical: 18.0, horizontal: 16.0),
          labelStyle: TextStyle(color: Colors.grey[700]),
          hintStyle: TextStyle(color: Colors.grey[400]),
          prefixIconColor: Colors.pinkAccent,
          errorStyle: const TextStyle(color: Colors.pink, fontSize: 14),
        ),
        textTheme: const TextTheme(
          headlineMedium: TextStyle(color: Colors.black87),
          headlineSmall: TextStyle(color: Colors.black87),
          titleMedium: TextStyle(color: Colors.black54),
          titleSmall: TextStyle(color: Colors.black87),
          titleLarge: TextStyle(color: Colors.black87),
          bodyMedium: TextStyle(color: Colors.black54),
        ),
      ),
      home: const AuthChecker(),
    );
  }
}

void main() {
  runApp(
    const ProviderScope(
      child: MyApp(),
    ),
  );
}
