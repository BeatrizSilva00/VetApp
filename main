import 'dart:async'; // Importa o pacote 'dart:async' para funcionalidades assíncronas como Future e Timer.
import 'package:flutter/material.dart'; // Importa o pacote fundamental do Flutter para construir interfaces de usuário.
import 'package:flutter_riverpod/flutter_riverpod.dart'; // Importa o Riverpod para gerenciamento de estado.
import 'package:collection/collection.dart'; // Importa o pacote 'collection' para utilitários de coleção como '.firstWhereOrNull'.

// ------------------------------
// Data Models (Modelos de Dados)
// ------------------------------

/// Representa o perfil de um usuário no sistema.
class UserProfile {
  final int id; // O identificador único do usuário.
  final String name; // O nome completo do usuário.
  final String email; // O endereço de e-mail do usuário, que também serve como nome de usuário.

  /// Construtor para criar uma nova instância de UserProfile.
  UserProfile({required this.id, required this.name, required this.email});
}

/// Representa um produto disponível na loja.
class Product {
  final int id; // O identificador único do produto.
  String name; // O nome do produto.
  String description; // Uma descrição detalhada do produto.
  double price; // O preço do produto.
  bool rxOnly; // Indica se o produto requer receita médica (true) ou não (false).
  String? imageUrl; // A URL da imagem do produto, pode ser nula.
  final String category; // A categoria à qual o produto pertence.

  /// Construtor para criar uma nova instância de Produto.
  Product({
    required this.id,
    required this.name,
    required this.description,
    required this.price,
    this.rxOnly = false, // rxOnly é opcional e padrão para false.
    this.imageUrl, // imageUrl é opcional.
    required this.category,
  });

  /// Cria uma nova instância de Produto com valores copiados e/ou modificados.
  Product copyWith({
    int? id, // Novo ID (opcional).
    String? name, // Novo nome (opcional).
    String? description, // Nova descrição (opcional).
    double? price, // Novo preço (opcional).
    bool? rxOnly, // Novo status de receita (opcional).
    String? imageUrl, // Nova URL da imagem (opcional).
    String? category, // Nova categoria (opcional).
  }) =>
      Product(
        id: id ?? this.id, // Usa o novo ID se fornecido, senão mantém o atual.
        name: name ?? this.name, // Usa o novo nome se fornecido, senão mantém o atual.
        description: description ?? this.description, // Usa a nova descrição se fornecida, senão mantém a atual.
        price: price ?? this.price, // Usa o novo preço se fornecido, senão mantém o atual.
        rxOnly: rxOnly ?? this.rxOnly, // Usa o novo status de receita se fornecido, senão mantém o atual.
        imageUrl: imageUrl ?? this.imageUrl, // Usa a nova URL da imagem se fornecida, senão mantém a atual.
        category: category ?? this.category, // Usa a nova categoria se fornecida, senão mantém a atual.
      );
}

/// Representa um item individual no carrinho de compras, com um produto e sua quantidade.
class CartItem {
  final Product product; // O produto adicionado ao carrinho.
  final int quantity; // A quantidade desse produto no carrinho.

  /// Construtor para criar uma nova instância de CartItem.
  CartItem({required this.product, required this.quantity});

  /// Cria uma nova instância de CartItem com valores copiados e/ou modificados.
  CartItem copyWith({Product? product, int? quantity}) {
    return CartItem(
      product: product ?? this.product, // Usa o novo produto se fornecido, senão mantém o atual.
      quantity: quantity ?? this.quantity, // Usa a nova quantidade se fornecida, senão mantém a atual.
    );
  }
}

/// Representa o estado atual da autenticação do usuário.
class AuthState {
  final bool isLoading; // Indica se uma operação de autenticação está em andamento.
  final bool isAuthed; // Indica se o usuário está autenticado.
  final String? error; // Mensagem de erro, se houver, durante a autenticação.
  final bool? isEmailError; // Indica se o erro está relacionado ao campo de e-mail.
  final UserProfile? currentUser; // O perfil do usuário atualmente logado, nulo se não houver login.

  /// Construtor constante para criar uma nova instância de AuthState com valores padrão.
  const AuthState({
    this.isLoading = false, // isLoading padrão é false.
    this.isAuthed = false, // isAuthed padrão é false.
    this.error, // error é nulo por padrão.
    this.isEmailError, // isEmailError é nulo por padrão.
    this.currentUser, // currentUser é nulo por padrão.
  });

  /// Cria uma nova instância de AuthState com valores copiados e/ou modificados.
  AuthState copyWith({
    bool? isLoading, // Novo status de carregamento (opcional).
    bool? isAuthed, // Novo status de autenticação (opcional).
    String? error, // Nova mensagem de erro (opcional, pode ser nula para limpar o erro).
    bool? isEmailError, // Novo status de erro de e-mail (opcional, pode ser nula para limpar).
    UserProfile? currentUser, // Novo perfil de usuário (opcional, pode ser nulo para deslogar).
  }) =>
      AuthState(
        isLoading: isLoading ?? this.isLoading, // Usa o novo isLoading se fornecido, senão mantém o atual.
        isAuthed: isAuthed ?? this.isAuthed, // Usa o novo isAuthed se fornecido, senão mantém o atual.
        error: error, // Usa o novo erro, permitindo limpar o erro se 'null' for passado explicitamente.
        isEmailError: isEmailError, // Usa o novo status de erro de e-mail, permitindo limpar.
        currentUser: currentUser, // Usa o novo perfil de usuário, permitindo limpar.
      );
}

/// Classe interna para armazenar detalhes de usuários registrados (email, senha, perfil).
class _RegisteredUserDetails {
  final String password; // A senha do usuário.
  final UserProfile userProfile; // O perfil do usuário associado.

  /// Construtor para criar uma nova instância de _RegisteredUserDetails.
  _RegisteredUserDetails({required this.password, required this.userProfile});
}

// ------------------------------
// State Notifiers (Controllers)
// ------------------------------

/// Gerencia o estado de autenticação do usuário.
class AuthController extends StateNotifier<AuthState> {
  /// Construtor que inicializa o estado com AuthState padrão.
  AuthController() : super(const AuthState());

  static const String _fixedUserEmail = 'admin@vet.com'; // Email de usuário fixo para teste.
  static const String _fixedUserPass = '123456'; // Senha de usuário fixo para teste.
  static const String _fixedUserName = 'Admin Vet'; // Nome de usuário fixo para teste.

  // Mapa para armazenar detalhes de usuários registrados dinamicamente.
  final Map<String, _RegisteredUserDetails> _registeredUsersDetails = {};

  /// Tenta fazer login com o email e senha fornecidos.
  Future<void> login(String email, String pass) async {
    // Define o estado para isLoading (carregando) e limpa quaisquer erros anteriores.
    state = state.copyWith(isLoading: true, error: null, isEmailError: null, currentUser: null);
    await Future.delayed(const Duration(milliseconds: 800)); // Simula um atraso de rede.

    bool isAuthenticated = false; // Flag para indicar se a autenticação foi bem-sucedida.
    UserProfile? userProfile; // Perfil do usuário autenticado.

    // Verifica se as credenciais correspondem ao usuário fixo.
    if (email == _fixedUserEmail && pass == _fixedUserPass) {
      isAuthenticated = true; // Autenticação bem-sucedida.
      userProfile = UserProfile(id: 1, name: _fixedUserName, email: email); // Cria o perfil do usuário fixo.
    }
    // Ou verifica se as credenciais correspondem a um usuário registrado dinamicamente.
    else if (_registeredUsersDetails.containsKey(email) && _registeredUsersDetails[email]!.password == pass) {
      isAuthenticated = true; // Autenticação bem-sucedida.
      userProfile = _registeredUsersDetails[email]!.userProfile; // Obtém o perfil do usuário registrado.
    }

    // Atualiza o estado com base no resultado da autenticação.
    if (isAuthenticated) {
      state = state.copyWith(
          isAuthed: true, // Define como autenticado.
          isLoading: false, // Remove o status de carregamento.
          error: null, // Limpa erros.
          isEmailError: null, // Limpa o status de erro de e-mail.
          currentUser: userProfile); // Define o usuário atual.
    } else {
      state = state.copyWith(
          isAuthed: false, // Define como não autenticado.
          isLoading: false, // Remove o status de carregamento.
          error: 'Cadastro inválido.', // Define mensagem de erro.
          isEmailError: false, // Indica que o erro não é especificamente do e-mail (mas da combinação).
          currentUser: null); // Limpa o usuário atual.
    }
  }

  /// Tenta registrar um novo usuário com o email, senha e nome fornecidos.
  Future<void> register(String email, String password, String name) async {
    // Define o estado para isLoading (carregando) e limpa quaisquer erros anteriores.
    state = state.copyWith(isLoading: true, error: null, isEmailError: null, currentUser: null);
    await Future.delayed(const Duration(milliseconds: 1200)); // Simula um atraso de rede.

    // Verifica se o email já está registrado (fixo ou dinâmico).
    if (_registeredUsersDetails.containsKey(email) || email == _fixedUserEmail) {
      state = state.copyWith(isLoading: false, error: 'Este email já está cadastrado.', isEmailError: true); // Define erro de email duplicado.
      return; // Sai da função.
    }

    // Cria um novo perfil de usuário.
    final UserProfile newUserProfile = UserProfile(id: email.hashCode.abs(), name: name, email: email);
    // Armazena os detalhes do novo usuário.
    _registeredUsersDetails[email] = _RegisteredUserDetails(password: password, userProfile: newUserProfile);

    // Atualiza o estado indicando sucesso (sem erro e sem carregamento).
    state = state.copyWith(isLoading: false, error: null, isEmailError: null);
  }

  /// Desloga o usuário, redefinindo o estado de autenticação para o padrão.
  void logout() {
    state = const AuthState(); // Define o estado para um AuthState vazio (não autenticado).
  }
}

/// Gerencia a lista de produtos disponíveis.
class ProductController extends StateNotifier<List<Product>> {
  /// Construtor que inicializa o estado com uma lista de produtos iniciais.
  ProductController() : super(_initialProducts);

  // Lista estática de produtos iniciais.
  static final List<Product> _initialProducts = [
    Product(
      id: 101,
      name: 'Anti-pulgas PetGuard',
      description: 'Proteção eficaz contra pulgas e carrapatos por 3 meses.',
      price: 89.90,
      rxOnly: false,
      imageUrl: 'https://images.tcdn.com.br/img/img_prod/469080/nexgard_antipulgas_caes_p_2kg_a_4kg_1_comprimido_boehringer_432_1_13f003e9c4b9fe1c31c67d5f5fb8f05f.png',
      category: 'Remédios',
    ),
    Product(
      id: 102,
      name: 'Antibiótico AmoxPet 250mg',
      description: 'Antibiótico de amplo espectro para infecções bacterianas.',
      price: 65.50,
      rxOnly: true,
      imageUrl: 'https://agrosolo.fbitsstatic.net/img/p/antibiotico-doxiciclina-doxitec-200mg-para-caes-16-comprimidos-89123/284689.jpg?w=700&h=700&v=202504291638',
      category: 'Remédios',
    ),
    Product(
      id: 103,
      name: 'Vermífugo CanineCare',
      description: 'Combate vermes intestinais em cães e gatos.',
      price: 35.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT8DWzbB9P9VERuidx9GwdwebtgsszUawJ9lw&s',
      category: 'Remédios',
    ),
    Product(
      id: 201,
      name: 'Ração Premium DogFit',
      description: 'Alimento completo e balanceado para cães adultos.',
      price: 120.00,
      rxOnly: false,
      imageUrl: 'https://www.petlove.com.br/images/products/273209/product/31027529907_Ra%C3%A7%C3%A3o_Seca_Dogfit_Gourmet_Carne_e_Vegetais_para_C%C3%A3es_Adultos_Porte_Pequeno_e_M%C3%A9dio_%281%29.jpg?1694521363',
      category: 'Rações',
    ),
    Product(
      id: 202,
      name: 'Ração Hipoalergênica CatHealthy',
      description: 'Fórmula especial para gatos com sensibilidade alimentar.',
      price: 95.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTowFVywEowD88opffFHbChTD67XcEtLfv1Ug&s',
      category: 'Rações',
    ),
    Product(
      id: 203,
      name: 'Petisco Dental Bites',
      description: 'Ajuda a reduzir o tártaro e manter a higiene bucal.',
      price: 25.00,
      rxOnly: false,
      imageUrl: 'https://http2.mlstatic.com/D_NQ_NP_605948-MLB47205197255_082021-O.webp',
      category: 'Rações',
    ),
    Product(
      id: 301,
      name: 'Bola Interativa PetPlay',
      description: 'Bola com dispenser de petiscos, estimula o raciocínio.',
      price: 45.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR3KF-xAehT3_BC-l6WPI866EPVZFkCwAzdtw&s',
      category: 'Brinquedos',
    ),
    Product(
      id: 302,
      name: 'Arranhador para Gatos Tower',
      description: 'Torre de arranhar com várias plataformas e brinquedos pendurados.',
      price: 180.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcT18aYym3TgRzV6I58fZJ0T6cs_BfiVL1OVQ&s',
      category: 'Brinquedos',
    ),
    Product(
      id: 303,
      name: 'Corda de Roer para Cães',
      description: 'Brinquedo resistente para cães que adoram mastigar.',
      price: 30.00,
      rxOnly: false,
      imageUrl: 'https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRbsbIIMKHjDlNv4hP7ZSH0a9-ZQ5xGslEbPw&s',
      category: 'Brinquedos',
    ),
  ];

  /// Retorna uma lista de produtos filtrados por categoria.
  List<Product> getProductsByCategory(String category) {
    return state.where((Product product) => product.category == category).toList(); // Filtra os produtos pela categoria e retorna uma nova lista.
  }
}

/// Gerencia o estado do carrinho de compras.
class CartController extends StateNotifier<List<CartItem>> {
  /// Construtor que inicializa o estado com uma lista de itens vazia.
  CartController() : super([]);

  /// Adiciona um produto ao carrinho ou aumenta sua quantidade se já existir.
  void addItem(Product product) {
    final List<CartItem> currentCart = List<CartItem>.from(state); // Cria uma cópia mutável da lista de itens do carrinho.
    final int index = currentCart.indexWhere((CartItem item) => item.product.id == product.id); // Encontra o índice do produto no carrinho.

    if (index != -1) {
      // Se o produto já estiver no carrinho, aumenta sua quantidade.
      final CartItem existingItem = currentCart[index]; // Obtém o item existente.
      currentCart[index] = existingItem.copyWith(quantity: existingItem.quantity + 1); // Cria um novo item com quantidade incrementada.
    } else {
      // Se o produto não estiver no carrinho, adiciona um novo item com quantidade 1.
      currentCart.add(CartItem(product: product, quantity: 1)); // Adiciona o novo item ao carrinho.
    }
    state = currentCart; // Atualiza o estado do carrinho.
  }

  /// Remove uma unidade de um produto do carrinho ou o remove completamente se a quantidade for 1.
  void removeItem(Product product) {
    final List<CartItem> currentCart = List<CartItem>.from(state); // Cria uma cópia mutável da lista de itens do carrinho.
    final int index = currentCart.indexWhere((CartItem item) => item.product.id == product.id); // Encontra o índice do produto no carrinho.

    if (index != -1) {
      // Se o produto estiver no carrinho.
      final CartItem existingItem = currentCart[index]; // Obtém o item existente.
      if (existingItem.quantity > 1) {
        // Se a quantidade for maior que 1, decrementa.
        currentCart[index] = existingItem.copyWith(quantity: existingItem.quantity - 1); // Cria um novo item com quantidade decrementada.
      } else {
        // Se a quantidade for 1, remove o item do carrinho.
        currentCart.removeAt(index); // Remove o item da lista.
      }
      state = currentCart; // Atualiza o estado do carrinho.
    }
  }

  /// Remove todas as unidades de um produto específico do carrinho.
  void removeAllItemsOfProduct(Product product) {
    state = state.where((CartItem item) => item.product.id != product.id).toList(); // Cria uma nova lista sem o produto especificado.
  }

  /// Esvazia completamente o carrinho.
  void clearCart() {
    state = <CartItem>[]; // Define o estado do carrinho como uma lista vazia.
  }

  /// Calcula o preço total de todos os itens no carrinho.
  double getTotalPrice() {
    return state.fold<double>(
        0.0, (double previousValue, CartItem item) => previousValue + (item.product.price * item.quantity)); // Soma o preço de cada item (preço * quantidade).
  }

  /// Calcula a quantidade total de itens (unidades) no carrinho.
  int getTotalQuantity() {
    return state.fold<int>(
        0, (int previousValue, CartItem item) => previousValue + item.quantity); // Soma a quantidade de cada item.
  }

  /// Verifica se um produto específico está no carrinho.
  bool isInCart(Product product) {
    return state.any((CartItem item) => item.product.id == product.id); // Retorna true se encontrar o produto no carrinho.
  }

  /// Retorna a quantidade de um produto específico no carrinho.
  int getProductQuantity(Product product) {
    final CartItem? item = state.firstWhereOrNull((CartItem item) => item.product.id == product.id); // Tenta encontrar o item no carrinho.
    return item?.quantity ?? 0; // Retorna a quantidade do item ou 0 se não for encontrado.
  }
}

// ------------------------------
// Riverpod Providers (Provedores Riverpod)
// ------------------------------

/// Provedor para o AuthController, gerenciando o estado de autenticação.
final authProvider = StateNotifierProvider<AuthController, AuthState>((ref) {
  return AuthController(); // Retorna uma nova instância de AuthController.
});

/// Provedor para o ProductController, gerenciando a lista de produtos.
final productProvider = StateNotifierProvider<ProductController, List<Product>>((ref) {
  return ProductController(); // Retorna uma nova instância de ProductController.
});

/// Provedor para o CartController, gerenciando o carrinho de compras.
final cartProvider = StateNotifierProvider<CartController, List<CartItem>>((ref) {
  return CartController(); // Retorna uma nova instância de CartController.
});

// ------------------------------
// UI Widgets (Widgets da Interface do Usuário)
// ------------------------------

/// Tela exibida após um registro bem-sucedido.
class RegistrationSuccessScreen extends StatelessWidget {
  final String registeredEmail; // O email do usuário recém-registrado.
  final String registeredName; // O nome do usuário recém-registrado.

  /// Construtor para RegistrationSuccessScreen.
  const RegistrationSuccessScreen({super.key, required this.registeredEmail, required this.registeredName});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Cadastro Concluído'), // Título da barra do aplicativo.
        automaticallyImplyLeading: false, // Desabilita o botão "voltar" padrão.
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0), // Adiciona preenchimento em todo o conteúdo.
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center, // Centraliza os filhos verticalmente.
            children: <Widget>[
              const Icon(Icons.check_circle_outline, size: 90, color: Colors.green), // Ícone de sucesso.
              const SizedBox(height: 32.0), // Espaço vertical.
              Text(
                'Parabéns, $registeredName!', // Mensagem de parabéns com o nome do usuário.
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.green, // Cor do texto verde.
                      fontWeight: FontWeight.bold, // Negrito.
                    ),
                textAlign: TextAlign.center, // Centraliza o texto.
              ),
              const SizedBox(height: 16.0), // Espaço vertical.
              Text(
                'Sua conta para "$registeredEmail" foi criada com sucesso.', // Mensagem de confirmação de conta criada.
                style: Theme.of(context).textTheme.titleMedium, // Estilo de texto médio do tema.
                textAlign: TextAlign.center, // Centraliza o texto.
              ),
              const SizedBox(height: 32.0), // Espaço vertical.
              ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop(); // Volta para a tela anterior (login).
                },
                child: const Text('Voltar para o Login'), // Texto do botão.
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Tela de login para os usuários.
class LoginScreen extends ConsumerStatefulWidget {
  /// Construtor para LoginScreen.
  const LoginScreen({super.key});

  @override
  ConsumerState<LoginScreen> createState() => _LoginScreenState(); // Cria o estado mutável para a tela.
}

class _LoginScreenState extends ConsumerState<LoginScreen> {
  final TextEditingController _emailController = TextEditingController(); // Controlador para o campo de e-mail.
  final TextEditingController _passwordController = TextEditingController(); // Controlador para o campo de senha.
  String? _emailLocalError; // Erro local para o campo de e-mail, se houver.
  String? _passwordLocalError; // Erro local para o campo de senha, se houver.

  @override
  void dispose() {
    _emailController.dispose(); // Libera os recursos do controlador de e-mail.
    _passwordController.dispose(); // Libera os recursos do controlador de senha.
    super.dispose(); // Chama o dispose da superclasse.
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider); // Observa o estado de autenticação.

    String? emailAuthError; // Erro de autenticação relacionado ao e-mail.
    String? passwordAuthError; // Erro de autenticação relacionado à senha.

    // Processa os erros retornados pelo AuthState.
    if (authState.error != null && !authState.isLoading && !authState.isAuthed) {
      if (authState.isEmailError == true) {
        emailAuthError = authState.error; // Atribui o erro ao campo de e-mail.
      } else if (authState.isEmailError == false) {
        passwordAuthError = authState.error; // Atribui o erro ao campo de senha.
      }
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Entrar no Sistema'), // Título da barra do aplicativo.
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0), // Adiciona preenchimento em todo o conteúdo.
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center, // Centraliza os filhos verticalmente.
            children: <Widget>[
              const Icon(Icons.pets, size: 90, color: Colors.pinkAccent), // Ícone de pets.
              const SizedBox(height: 32.0), // Espaço vertical.
              Text(
                'Bem-vindo ao VetApp', // Mensagem de boas-vindas.
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.pinkAccent, // Cor do texto.
                      fontWeight: FontWeight.bold, // Negrito.
                    ),
                textAlign: TextAlign.center, // Centraliza o texto.
              ),
              const SizedBox(height: 32.0), // Espaço vertical.
              TextField(
                controller: _emailController, // Associa o controlador de e-mail.
                onChanged: (_) {
                  if (_emailLocalError != null) {
                    setState(() => _emailLocalError = null); // Limpa o erro local do e-mail ao digitar.
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Email', // Rótulo do campo.
                  prefixIcon: const Icon(Icons.email), // Ícone à esquerda.
                  hintText: 'admin@vet.com', // Texto de dica.
                  errorText: _emailLocalError ?? emailAuthError, // Exibe erro local ou de autenticação.
                ),
                keyboardType: TextInputType.emailAddress, // Tipo de teclado para e-mail.
              ),
              const SizedBox(height: 16.0), // Espaço vertical.
              TextField(
                controller: _passwordController, // Associa o controlador de senha.
                onChanged: (_) {
                  if (_passwordLocalError != null) {
                    setState(() => _passwordLocalError = null); // Limpa o erro local da senha ao digitar.
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Senha', // Rótulo do campo.
                  prefixIcon: const Icon(Icons.lock), // Ícone à esquerda.
                  hintText: '123456', // Texto de dica.
                  errorText: _passwordLocalError ?? passwordAuthError, // Exibe erro local ou de autenticação.
                ),
                obscureText: true, // Oculta o texto digitado (para senhas).
              ),
              const SizedBox(height: 32.0), // Espaço vertical.
              if (authState.isLoading)
                const CircularProgressIndicator() // Exibe um indicador de progresso se estiver carregando.
              else
                ElevatedButton(
                  onPressed: () {
                    final String email = _emailController.text.trim(); // Obtém e-mail e remove espaços.
                    final String password = _passwordController.text.trim(); // Obtém senha e remove espaços.

                    bool hasLocalError = false; // Flag para erros de validação local.
                    String? tempEmailError; // Erro temporário para e-mail.
                    String? tempPasswordError; // Erro temporário para senha.

                    // Validação local do e-mail.
                    if (email.isEmpty) {
                      tempEmailError = 'Por favor, preencha seu email.';
                      hasLocalError = true;
                    }
                    // Validação local da senha.
                    if (password.isEmpty) {
                      tempPasswordError = 'Por favor, preencha sua senha.';
                      hasLocalError = true;
                    }

                    setState(() {
                      _emailLocalError = tempEmailError; // Atualiza o erro local do e-mail.
                      _passwordLocalError = tempPasswordError; // Atualiza o erro local da senha.
                    });

                    if (hasLocalError) {
                      return; // Se houver erros locais, não prossegue com o login.
                    }

                    // Limpa erros anteriores do provedor de autenticação antes de tentar login.
                    ref.read(authProvider.notifier).state = authState.copyWith(error: null, isEmailError: null);
                    // Chama o método de login no AuthController.
                    ref.read(authProvider.notifier).login(email, password);
                  },
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size.fromHeight(50), // Define a altura mínima do botão.
                  ),
                  child: const Text('Login'), // Texto do botão de login.
                ),
              const SizedBox(height: 20.0), // Espaço vertical.
              TextButton(
                onPressed: () {
                  // Limpa erros do provedor de autenticação antes de navegar para o registro.
                  ref.read(authProvider.notifier).state =
                      ref.read(authProvider.notifier).state.copyWith(error: null, isEmailError: null);
                  Navigator.of(context).push(
                    MaterialPageRoute<void>(
                      builder: (BuildContext context) => const RegisterScreen(), // Navega para a tela de registro.
                    ),
                  );
                },
                child: const Text(
                  'Não tem uma conta? Cadastre-se aqui!', // Texto para registrar.
                  style: TextStyle(color: Colors.pinkAccent, fontSize: 16), // Estilo do texto.
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Tela de registro para novos usuários.
class RegisterScreen extends ConsumerStatefulWidget {
  /// Construtor para RegisterScreen.
  const RegisterScreen({super.key});

  @override
  ConsumerState<RegisterScreen> createState() => _RegisterScreenState(); // Cria o estado mutável para a tela.
}

class _RegisterScreenState extends ConsumerState<RegisterScreen> {
  final TextEditingController _nameController = TextEditingController(); // Controlador para o campo de nome.
  final TextEditingController _emailController = TextEditingController(); // Controlador para o campo de e-mail.
  final TextEditingController _passwordController = TextEditingController(); // Controlador para o campo de senha.
  String? _nameLocalError; // Erro local para o campo de nome.
  String? _emailLocalError; // Erro local para o campo de e-mail.
  String? _passwordLocalError; // Erro local para o campo de senha.

  @override
  void dispose() {
    _nameController.dispose(); // Libera os recursos do controlador de nome.
    _emailController.dispose(); // Libera os recursos do controlador de e-mail.
    _passwordController.dispose(); // Libera os recursos do controlador de senha.
    super.dispose(); // Chama o dispose da superclasse.
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider); // Observa o estado de autenticação.

    String? emailAuthError; // Erro de autenticação relacionado ao e-mail.

    // Processa os erros retornados pelo AuthState, especificamente para o e-mail.
    if (authState.error != null && !authState.isLoading) {
      if (authState.isEmailError == true) {
        emailAuthError = authState.error; // Atribui o erro ao campo de e-mail.
      }
    }

    // Ouve as mudanças no estado de autenticação para navegar após o registro bem-sucedido.
    ref.listen<AuthState>(authProvider, (AuthState? previous, AuthState current) {
      // Se estava carregando e não está mais, e não há erro, significa sucesso no registro.
      if (previous?.isLoading == true && !current.isLoading && current.error == null) {
        Navigator.of(context).pushReplacement(
          MaterialPageRoute<void>(
            builder: (BuildContext context) => RegistrationSuccessScreen(
              registeredEmail: _emailController.text, // Passa o e-mail registrado para a tela de sucesso.
              registeredName: _nameController.text, // Passa o nome registrado para a tela de sucesso.
            ),
          ),
        );
      }
    });

    return Scaffold(
      appBar: AppBar(
        title: const Text('Cadastro de Usuário'), // Título da barra do aplicativo.
      ),
      body: Center(
        child: SingleChildScrollView(
          padding: const EdgeInsets.all(24.0), // Adiciona preenchimento em todo o conteúdo.
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center, // Centraliza os filhos verticalmente.
            children: <Widget>[
              const Icon(Icons.person_add, size: 90, color: Colors.pinkAccent), // Ícone de adicionar pessoa.
              const SizedBox(height: 32.0), // Espaço vertical.
              Text(
                'Criar Nova Conta', // Título da seção.
                style: Theme.of(context).textTheme.headlineMedium?.copyWith(
                      color: Colors.pinkAccent, // Cor do texto.
                      fontWeight: FontWeight.bold, // Negrito.
                    ),
                textAlign: TextAlign.center, // Centraliza o texto.
              ),
              const SizedBox(height: 32.0), // Espaço vertical.
              TextField(
                controller: _nameController, // Associa o controlador de nome.
                onChanged: (_) {
                  if (_nameLocalError != null) {
                    setState(() => _nameLocalError = null); // Limpa o erro local do nome ao digitar.
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Nome Completo', // Rótulo do campo.
                  prefixIcon: const Icon(Icons.person), // Ícone à esquerda.
                  hintText: 'Seu nome', // Texto de dica.
                  errorText: _nameLocalError, // Exibe erro local.
                ),
                keyboardType: TextInputType.name, // Tipo de teclado para nome.
              ),
              const SizedBox(height: 16.0), // Espaço vertical.
              TextField(
                controller: _emailController, // Associa o controlador de e-mail.
                onChanged: (_) {
                  if (_emailLocalError != null) {
                    setState(() => _emailLocalError = null); // Limpa o erro local do e-mail ao digitar.
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Email', // Rótulo do campo.
                  prefixIcon: const Icon(Icons.email), // Ícone à esquerda.
                  hintText: 'seu.email@exemplo.com', // Texto de dica.
                  errorText: _emailLocalError ?? emailAuthError, // Exibe erro local ou de autenticação.
                ),
                keyboardType: TextInputType.emailAddress, // Tipo de teclado para e-mail.
              ),
              const SizedBox(height: 16.0), // Espaço vertical.
              TextField(
                controller: _passwordController, // Associa o controlador de senha.
                onChanged: (_) {
                  if (_passwordLocalError != null) {
                    setState(() => _passwordLocalError = null); // Limpa o erro local da senha ao digitar.
                  }
                },
                decoration: InputDecoration(
                  labelText: 'Senha', // Rótulo do campo.
                  prefixIcon: const Icon(Icons.lock), // Ícone à esquerda.
                  hintText: '****', // Texto de dica.
                  errorText: _passwordLocalError, // Exibe erro local.
                ),
                obscureText: true, // Oculta o texto digitado (para senhas).
              ),
              const SizedBox(height: 32.0), // Espaço vertical.
              if (authState.isLoading)
                const CircularProgressIndicator() // Exibe um indicador de progresso se estiver carregando.
              else
                ElevatedButton(
                  onPressed: () {
                    final String name = _nameController.text.trim(); // Obtém nome e remove espaços.
                    final String email = _emailController.text.trim(); // Obtém e-mail e remove espaços.
                    final String password = _passwordController.text.trim(); // Obtém senha e remove espaços.

                    bool hasLocalError = false; // Flag para erros de validação local.
                    String? tempNameError; // Erro temporário para nome.
                    String? tempEmailError; // Erro temporário para e-mail.
                    String? tempPasswordError; // Erro temporário para senha.

                    // Validação local do nome.
                    if (name.isEmpty) {
                      tempNameError = 'Por favor, preencha seu nome.';
                      hasLocalError = true;
                    }
                    // Validação local do e-mail.
                    if (email.isEmpty) {
                      tempEmailError = 'Por favor, preencha seu email para cadastro.';
                      hasLocalError = true;
                    }
                    // Validação local da senha.
                    if (password.isEmpty) {
                      tempPasswordError = 'Por favor, preencha sua senha para cadastro.';
                      hasLocalError = true;
                    }

                    setState(() {
                      _nameLocalError = tempNameError; // Atualiza o erro local do nome.
                      _emailLocalError = tempEmailError; // Atualiza o erro local do e-mail.
                      _passwordLocalError = tempPasswordError; // Atualiza o erro local da senha.
                    });

                    if (hasLocalError) {
                      return; // Se houver erros locais, não prossegue com o registro.
                    }

                    // Limpa erros anteriores do provedor de autenticação antes de tentar registrar.
                    ref.read(authProvider.notifier).state = authState.copyWith(error: null, isEmailError: null);
                    // Chama o método de registro no AuthController.
                    ref.read(authProvider.notifier).register(email, password, name);
                  },
                  style: ElevatedButton.styleFrom(
                    minimumSize: const Size.fromHeight(50), // Define a altura mínima do botão.
                  ),
                  child: const Text('Cadastrar'), // Texto do botão de cadastro.
                ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Cartão de exibição para um único produto.
class ProductCard extends ConsumerWidget {
  final Product product; // O produto a ser exibido no cartão.

  /// Construtor para ProductCard.
  const ProductCard({super.key, required this.product});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 8.0), // Margem vertical para o cartão.
      elevation: 2, // Elevação do cartão.
      shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)), // Borda arredondada do cartão.
      child: Padding(
        padding: const EdgeInsets.all(16.0), // Preenchimento interno do cartão.
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start, // Alinha os filhos à esquerda.
          children: <Widget>[
            Row(
              crossAxisAlignment: CrossAxisAlignment.start, // Alinha os filhos no início da linha.
              children: <Widget>[
                ClipRRect(
                  borderRadius: BorderRadius.circular(8.0), // Borda arredondada para a imagem.
                  child: Image.network(
                    product.imageUrl ?? 'https://www.gstatic.com/flutter-onestack-prototype/genui/example_1.jpg', // Exibe a imagem do produto ou um placeholder.
                    width: 80, // Largura da imagem.
                    height: 80, // Altura da imagem.
                    fit: BoxFit.cover, // Ajuste da imagem para preencher o espaço.
                    errorBuilder: (BuildContext context, Object error, StackTrace? stackTrace) => Container(
                      width: 80, // Largura do container de erro.
                      height: 80, // Altura do container de erro.
                      color: Colors.grey[200], // Cor de fundo do container de erro.
                      child: const Icon(Icons.image_not_supported, color: Colors.grey), // Ícone de imagem não suportada.
                    ),
                  ),
                ),
                const SizedBox(width: 16.0), // Espaço horizontal.
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start, // Alinha os filhos à esquerda.
                    children: <Widget>[
                      Text(
                        product.name, // Nome do produto.
                        style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold), // Estilo do texto do nome.
                        maxLines: 2, // Limita o nome a duas linhas.
                        overflow: TextOverflow.ellipsis, // Adiciona reticências se o texto exceder.
                      ),
                      const SizedBox(height: 4.0), // Espaço vertical.
                      Text(
                        product.description, // Descrição do produto.
                        style: Theme.of(context).textTheme.bodyMedium, // Estilo do texto da descrição.
                        maxLines: 3, // Limita a descrição a três linhas.
                        overflow: TextOverflow.ellipsis, // Adiciona reticências se o texto exceder.
                      ),
                      const SizedBox(height: 8.0), // Espaço vertical.
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween, // Distribui o espaço entre os filhos.
                        children: <Widget>[
                          Text(
                            'R\$ ${product.price.toStringAsFixed(2)}', // Preço do produto formatado.
                            style: Theme.of(context)
                                .textTheme.titleSmall?.copyWith(color: Colors.green[700], fontWeight: FontWeight.bold), // Estilo do texto do preço.
                          ),
                          if (product.rxOnly)
                            Chip(
                              label: const Text('Com receita', style: TextStyle(fontSize: 12, color: Colors.white)), // Rótulo do chip.
                              backgroundColor: Colors.red[400], // Cor de fundo do chip.
                              materialTapTargetSize: MaterialTapTargetSize.shrinkWrap, // Ajusta o tamanho do toque.
                            ),
                        ],
                      ),
                    ],
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16.0), // Espaço vertical.
            SizedBox(
              width: double.infinity, // O botão ocupa toda a largura disponível.
              child: ElevatedButton.icon(
                icon: const Icon(Icons.add_shopping_cart, size: 20), // Ícone do botão.
                label: const Text('Adicionar ao Carrinho', style: TextStyle(fontSize: 16)), // Texto do botão.
                onPressed: () {
                  ref.read(cartProvider.notifier).addItem(product); // Adiciona o produto ao carrinho.
                  ScaffoldMessenger.of(context).showSnackBar(
                    SnackBar(
                      content: Text('${product.name} adicionado ao carrinho!'), // Mensagem de sucesso.
                      duration: const Duration(seconds: 1), // Duração do snackbar.
                    ),
                  );
                },
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// Tela de exibição do carrinho de compras.
class CartScreen extends ConsumerWidget {
  /// Construtor para CartScreen.
  const CartScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final List<CartItem> cartItems = ref.watch(cartProvider); // Observa a lista de itens no carrinho.
    final CartController cartController = ref.read(cartProvider.notifier); // Obtém o controlador do carrinho.
    final double totalPrice = cartController.getTotalPrice(); // Calcula o preço total do carrinho.

    return Scaffold(
      appBar: AppBar(
        title: const Text('Meu Carrinho'), // Título da barra do aplicativo.
      ),
      body: cartItems.isEmpty // Verifica se o carrinho está vazio.
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center, // Centraliza os filhos verticalmente.
                children: <Widget>[
                  const Icon(Icons.shopping_cart_outlined, size: 90, color: Colors.grey), // Ícone de carrinho vazio.
                  const SizedBox(height: 24), // Espaço vertical.
                  Text(
                    'Seu carrinho está vazio!', // Mensagem de carrinho vazio.
                    style: Theme.of(context).textTheme.headlineSmall?.copyWith(color: Colors.grey[600]), // Estilo do texto.
                  ),
                  const SizedBox(height: 16), // Espaço vertical.
                  ElevatedButton(
                    onPressed: () {
                      Navigator.of(context).pop(); // Volta para a tela anterior (biblioteca de produtos).
                    },
                    child: const Text('Continuar Comprando'), // Texto do botão.
                  ),
                ],
              ),
            )
          : Column(
              children: <Widget>[
                Expanded(
                  child: ListView.builder(
                    padding: const EdgeInsets.all(16.0), // Preenchimento da lista.
                    itemCount: cartItems.length, // Número de itens no carrinho.
                    itemBuilder: (BuildContext context, int index) {
                      final CartItem item = cartItems[index]; // Item do carrinho atual.
                      return Card(
                        margin: const EdgeInsets.symmetric(vertical: 8.0), // Margem vertical para o cartão do item.
                        elevation: 2, // Elevação do cartão.
                        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)), // Borda arredondada.
                        child: Padding(
                          padding: const EdgeInsets.all(16.0), // Preenchimento interno.
                          child: Row(
                            crossAxisAlignment: CrossAxisAlignment.start, // Alinha os filhos no início da linha.
                            children: <Widget>[
                              ClipRRect(
                                borderRadius: BorderRadius.circular(8.0), // Borda arredondada para a imagem.
                                child: Image.network(
                                  item.product.imageUrl ?? 'https://www.gstatic.com/flutter-onestack-prototype/genui/example_1.jpg', // Imagem do produto ou placeholder.
                                  width: 60, // Largura da imagem.
                                  height: 60, // Altura da imagem.
                                  fit: BoxFit.cover, // Ajuste da imagem.
                                  errorBuilder: (BuildContext context, Object error, StackTrace? stackTrace) => Container(
                                    width: 60, // Largura do container de erro.
                                    height: 60, // Altura do container de erro.
                                    color: Colors.grey[200], // Cor de fundo do container de erro.
                                    child: const Icon(Icons.image_not_supported, color: Colors.grey), // Ícone de imagem não suportada.
                                  ),
                                ),
                              ),
                              const SizedBox(width: 16.0), // Espaço horizontal.
                              Expanded(
                                child: Column(
                                  crossAxisAlignment: CrossAxisAlignment.start, // Alinha os filhos à esquerda.
                                  children: <Widget>[
                                    Text(
                                      item.product.name, // Nome do produto.
                                      style: Theme.of(context).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold), // Estilo do texto do nome.
                                      maxLines: 2, // Limita o nome a duas linhas.
                                      overflow: TextOverflow.ellipsis, // Adiciona reticências.
                                    ),
                                    const SizedBox(height: 4.0), // Espaço vertical.
                                    Text(
                                      'R\$ ${item.product.price.toStringAsFixed(2)}', // Preço do produto formatado.
                                      style: Theme.of(context)
                                          .textTheme.titleSmall?.copyWith(color: Colors.green[700]), // Estilo do texto do preço.
                                    ),
                                    const SizedBox(height: 8.0), // Espaço vertical.
                                    Row(
                                      children: <Widget>[
                                        IconButton(
                                          icon: const Icon(Icons.remove_circle_outline, color: Colors.red), // Ícone para remover quantidade.
                                          onPressed: () => cartController.removeItem(item.product), // Chama para remover uma unidade.
                                        ),
                                        Text(
                                          '${item.quantity}', // Quantidade do item.
                                          style: Theme.of(context).textTheme.titleMedium, // Estilo do texto da quantidade.
                                        ),
                                        IconButton(
                                          icon: const Icon(Icons.add_circle_outline, color: Colors.green), // Ícone para adicionar quantidade.
                                          onPressed: () => cartController.addItem(item.product), // Chama para adicionar uma unidade.
                                        ),
                                        const Spacer(), // Espaço flexível.
                                        IconButton(
                                          icon: const Icon(Icons.delete, color: Colors.grey), // Ícone para remover tudo.
                                          onPressed: () => cartController.removeAllItemsOfProduct(item.product), // Chama para remover todas as unidades do produto.
                                        ),
                                      ],
                                    ),
                                  ],
                                ),
                              ),
                            ],
                          ),
                        ),
                      );
                    },
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(16.0), // Preenchimento para a seção de total e botões.
                  child: Column(
                    children: <Widget>[
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween, // Distribui o espaço entre os filhos.
                        children: <Widget>[
                          Text(
                            'Total:', // Rótulo do total.
                            style: Theme.of(context).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold), // Estilo do texto.
                          ),
                          Text(
                            'R\$ ${totalPrice.toStringAsFixed(2)}', // Preço total formatado.
                            style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                                  fontWeight: FontWeight.bold, // Negrito.
                                  color: Colors.green[700], // Cor do texto.
                                ),
                          ),
                        ],
                      ),
                      const SizedBox(height: 16), // Espaço vertical.
                      SizedBox(
                        width: double.infinity, // Botão ocupa toda a largura.
                        child: ElevatedButton.icon(
                          icon: const Icon(Icons.payment), // Ícone de pagamento.
                          label: const Text('Finalizar Compra'), // Texto do botão.
                          onPressed: () {
                            if (cartItems.isNotEmpty) {
                              cartController.clearCart(); // Limpa o carrinho após a compra.
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Compra finalizada com sucesso!'), // Mensagem de sucesso.
                                  duration: Duration(seconds: 2), // Duração do snackbar.
                                ),
                              );
                              Navigator.of(context).pop(); // Volta para a tela anterior.
                            }
                          },
                        ),
                      ),
                      const SizedBox(height: 8), // Espaço vertical.
                      SizedBox(
                        width: double.infinity, // Botão ocupa toda a largura.
                        child: TextButton.icon(
                          icon: const Icon(Icons.remove_shopping_cart, color: Colors.red), // Ícone de remover carrinho.
                          label: const Text('Limpar Carrinho', style: TextStyle(color: Colors.red)), // Texto do botão.
                          onPressed: () {
                            if (cartItems.isNotEmpty) {
                              cartController.clearCart(); // Limpa o carrinho.
                              ScaffoldMessenger.of(context).showSnackBar(
                                const SnackBar(
                                  content: Text('Carrinho esvaziado!'), // Mensagem de carrinho esvaziado.
                                  duration: Duration(seconds: 1), // Duração do snackbar.
                                ),
                              );
                            }
                          },
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
    );
  }
}

/// Tela principal da biblioteca do aplicativo, exibindo produtos por categoria e informações do usuário.
class AppLibraryScreen extends ConsumerStatefulWidget {
  /// Construtor para AppLibraryScreen.
  const AppLibraryScreen({super.key});

  @override
  ConsumerState<AppLibraryScreen> createState() => _AppLibraryScreenState(); // Cria o estado mutável para a tela.
}

class _AppLibraryScreenState extends ConsumerState<AppLibraryScreen> with SingleTickerProviderStateMixin {
  late TabController _tabController; // Controlador para as abas.
  static const List<String> _productCategories = ['Remédios', 'Rações', 'Brinquedos']; // Lista de categorias de produtos.

  @override
  void initState() {
    super.initState(); // Chama o initState da superclasse.
    _tabController = TabController(length: _productCategories.length, vsync: this); // Inicializa o TabController com o número de categorias e o ticker.
  }

  @override
  void dispose() {
    _tabController.dispose(); // Libera os recursos do TabController.
    super.dispose(); // Chama o dispose da superclasse.
  }

  @override
  Widget build(BuildContext context) {
    final AuthState authState = ref.watch(authProvider); // Observa o estado de autenticação.
    final UserProfile? currentUser = authState.currentUser; // Obtém o perfil do usuário atual.
    final List<Product> allProducts = ref.watch(productProvider); // Observa todos os produtos.
    final int cartItemCount = ref.watch(cartProvider.notifier).getTotalQuantity(); // Obtém a contagem total de itens no carrinho.

    // Se não houver usuário logado, exibe uma tela de erro.
    if (currentUser == null) {
      return Scaffold(
        appBar: AppBar(title: const Text('Erro')), // Título da barra de erro.
        body: Center(
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center, // Centraliza os filhos.
            children: <Widget>[
              const Icon(Icons.error_outline, size: 60, color: Colors.red), // Ícone de erro.
              const SizedBox(height: 16), // Espaço vertical.
              Text('Nenhum usuário logado.', style: Theme.of(context).textTheme.titleMedium), // Mensagem de erro.
              const SizedBox(height: 16), // Espaço vertical.
              ElevatedButton(
                onPressed: () {
                  Navigator.of(context).pop(); // Volta para a tela anterior.
                },
                child: const Text('Voltar'), // Texto do botão.
              ),
            ],
          ),
        ),
      );
    }

    return Scaffold(
      appBar: AppBar(
        title: const Text('Biblioteca do Aplicativo'), // Título da barra do aplicativo.
        actions: <Widget>[
          Stack(
            children: <Widget>[
              IconButton(
                icon: const Icon(Icons.shopping_cart), // Ícone do carrinho de compras.
                onPressed: () {
                  Navigator.of(context).push(
                    MaterialPageRoute<void>(
                      builder: (BuildContext context) => const CartScreen(), // Navega para a tela do carrinho.
                    ),
                  );
                },
              ),
              if (cartItemCount > 0)
                Positioned(
                  right: 8, // Posição direita do badge.
                  top: 8, // Posição superior do badge.
                  child: Container(
                    padding: const EdgeInsets.all(2), // Preenchimento interno do badge.
                    decoration: BoxDecoration(
                      color: Colors.red, // Cor de fundo do badge.
                      borderRadius: BorderRadius.circular(10), // Borda arredondada do badge.
                    ),
                    constraints: const BoxConstraints(
                      minWidth: 16, // Largura mínima do badge.
                      minHeight: 16, // Altura mínima do badge.
                    ),
                    child: Text(
                      '$cartItemCount', // Mostra a contagem de itens no carrinho.
                      style: const TextStyle(
                        color: Colors.white, // Cor do texto do badge.
                        fontSize: 10, // Tamanho da fonte do badge.
                      ),
                      textAlign: TextAlign.center, // Centraliza o texto do badge.
                    ),
                  ),
                ),
            ],
          ),
          IconButton(
            icon: const Icon(Icons.logout), // Ícone de logout.
            onPressed: () {
              ref.read(authProvider.notifier).logout(); // Chama o método de logout do AuthController.
              ref.read(cartProvider.notifier).clearCart(); // Limpa o carrinho ao fazer logout.
            },
            tooltip: 'Sair', // Dica de ferramenta para o botão.
          ),
        ],
        bottom: TabBar(
          controller: _tabController, // Associa o TabController.
          tabs: _productCategories.map<Widget>((String category) => Tab(text: category)).toList(), // Cria uma Tab para cada categoria.
          labelColor: Colors.white, // Cor do texto da aba selecionada.
          unselectedLabelColor: Colors.white70, // Cor do texto da aba não selecionada.
          indicatorColor: Colors.white, // Cor do indicador da aba.
        ),
      ),
      body: Column(
        children: <Widget>[
          Padding(
            padding: const EdgeInsets.all(16.0), // Preenchimento para a seção de informações do usuário.
            child: Card(
              elevation: 4, // Elevação do cartão.
              shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)), // Borda arredondada.
              child: Padding(
                padding: const EdgeInsets.all(16.0), // Preenchimento interno.
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start, // Alinha os filhos à esquerda.
                  children: <Widget>[
                    Text(
                      'Informações do Usuário:', // Título da seção.
                      style: Theme.of(context).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold), // Estilo do texto.
                    ),
                    const SizedBox(height: 8), // Espaço vertical.
                    Row(
                      children: <Widget>[
                        const Icon(Icons.person, color: Colors.pinkAccent), // Ícone de pessoa.
                        const SizedBox(width: 8), // Espaço horizontal.
                        Text('Nome: ${currentUser.name}', style: Theme.of(context).textTheme.titleMedium), // Nome do usuário.
                      ],
                    ),
                    const SizedBox(height: 4), // Espaço vertical.
                    Row(
                      children: <Widget>[
                        const Icon(Icons.badge, color: Colors.pinkAccent), // Ícone de crachá.
                        const SizedBox(width: 8), // Espaço horizontal.
                        Text('ID: ${currentUser.id}', style: Theme.of(context).textTheme.titleMedium), // ID do usuário.
                      ],
                    ),
                    const SizedBox(height: 4), // Espaço vertical.
                    Row(
                      children: <Widget>[
                        const Icon(Icons.email, color: Colors.pinkAccent), // Ícone de e-mail.
                        const SizedBox(width: 8), // Espaço horizontal.
                        Text('Email: ${currentUser.email}', style: Theme.of(context).textTheme.titleMedium), // E-mail do usuário.
                      ],
                    ),
                  ],
                ),
              ),
            ),
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController, // Associa o TabController.
              children: _productCategories.map<Widget>((String category) {
                final List<Product> categoryProducts = allProducts.where((Product p) => p.category == category).toList(); // Filtra produtos pela categoria.
                if (categoryProducts.isEmpty) {
                  return Center(
                    child: Text('Nenhum item encontrado na categoria "$category".', style: Theme.of(context).textTheme.titleMedium), // Mensagem se a categoria estiver vazia.
                  );
                }
                return ListView.builder(
                  padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0), // Preenchimento da lista.
                  itemCount: categoryProducts.length, // Número de produtos na categoria.
                  itemBuilder: (BuildContext context, int index) {
                    final Product product = categoryProducts[index]; // Produto atual.
                    return ProductCard(product: product); // Exibe um ProductCard para cada produto.
                  },
                );
              }).toList(),
            ),
          ),
        ],
      ),
    );
  }
}

/// Tela principal exibida após o login bem-sucedido.
class HomeScreen extends ConsumerWidget {
  /// Construtor para HomeScreen.
  const HomeScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AuthState authState = ref.watch(authProvider); // Observa o estado de autenticação.
    final UserProfile? currentUser = authState.currentUser; // Obtém o perfil do usuário atual.

    return Scaffold(
      appBar: AppBar(
        title: const Text('Página Principal'), // Título da barra do aplicativo.
        actions: <Widget>[
          IconButton(
            icon: const Icon(Icons.logout), // Ícone de logout.
            onPressed: () {
              ref.read(authProvider.notifier).logout(); // Chama o método de logout do AuthController.
              ref.read(cartProvider.notifier).clearCart(); // Limpa o carrinho ao fazer logout.
            },
            tooltip: 'Sair', // Dica de ferramenta.
          ),
        ],
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center, // Centraliza os filhos verticalmente.
          children: <Widget>[
            const Icon(Icons.check_circle_outline, size: 90, color: Colors.green), // Ícone de sucesso.
            const SizedBox(height: 32.0), // Espaço vertical.
            Text(
              'Você está logado!', // Mensagem de status de login.
              style: Theme.of(context).textTheme.headlineSmall, // Estilo do texto.
            ),
            const SizedBox(height: 12.0), // Espaço vertical.
            Text(
              'Bem-vindo de volta, ${currentUser?.name ?? 'usuário'}!', // Mensagem de boas-vindas com o nome do usuário.
              style: Theme.of(context).textTheme.titleMedium, // Estilo do texto.
            ),
            const SizedBox(height: 32.0), // Espaço vertical.
            ElevatedButton.icon(
              onPressed: () {
                Navigator.of(context).push(
                  MaterialPageRoute<void>(
                    builder: (BuildContext context) => const AppLibraryScreen(), // Navega para a tela da biblioteca do aplicativo.
                  ),
                );
              },
              icon: const Icon(Icons.apps), // Ícone de aplicativos.
              label: const Text('Ir para o App'), // Texto do botão.
            ),
            const SizedBox(height: 16.0), // Espaço vertical.
            TextButton(
              onPressed: () {
                ref.read(authProvider.notifier).logout(); // Chama o método de logout do AuthController.
                ref.read(cartProvider.notifier).clearCart(); // Limpa o carrinho ao fazer logout.
              },
              child: const Text('Sair da Conta'), // Texto do botão de sair.
            ),
          ],
        ),
      ),
    );
  }
}

/// Widget que verifica o estado de autenticação e exibe a tela apropriada.
class AuthChecker extends ConsumerWidget {
  /// Construtor para AuthChecker.
  const AuthChecker({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final AuthState authState = ref.watch(authProvider); // Observa o estado de autenticação.

    if (authState.isAuthed) {
      return const HomeScreen(); // Se autenticado, exibe a HomeScreen.
    } else {
      return const LoginScreen(); // Se não autenticado, exibe a LoginScreen.
    }
  }
}

/// O widget raiz da aplicação Flutter.
class MyApp extends StatelessWidget {
  /// Construtor para MyApp.
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'VetApp', // Título da aplicação.
      debugShowCheckedModeBanner: false, // Remove a faixa de debug.
      theme: ThemeData(
        primarySwatch: Colors.pink, // Cor primária do tema.
        visualDensity: VisualDensity.adaptivePlatformDensity, // Adapta a densidade visual à plataforma.
        appBarTheme: const AppBarTheme(
          backgroundColor: Colors.pinkAccent, // Cor de fundo da barra do aplicativo.
          foregroundColor: Colors.white, // Cor dos ícones e texto na barra do aplicativo.
          centerTitle: true, // Centraliza o título da barra do aplicativo.
          titleTextStyle: TextStyle(
            fontSize: 20, // Tamanho da fonte do título.
            fontWeight: FontWeight.bold, // Negrito para o título.
            color: Colors.white, // Cor do título.
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData(
          style: ElevatedButton.styleFrom(
            backgroundColor: Colors.pinkAccent, // Cor de fundo dos botões elevados.
            foregroundColor: Colors.white, // Cor do texto e ícones dos botões elevados.
            padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15), // Preenchimento dos botões.
            textStyle: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold), // Estilo do texto dos botões.
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(10), // Borda arredondada dos botões.
            ),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10), // Borda arredondada para campos de texto.
            borderSide: BorderSide.none, // Remove a borda padrão.
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10), // Borda arredondada quando focado.
            borderSide: const BorderSide(color: Colors.pinkAccent, width: 2), // Borda rosa quando focado.
          ),
          errorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10), // Borda arredondada em caso de erro.
            borderSide: const BorderSide(color: Colors.pink, width: 2), // Borda rosa em caso de erro.
          ),
          focusedErrorBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(10), // Borda arredondada quando focado com erro.
            borderSide: const BorderSide(color: Colors.pink, width: 2), // Borda rosa quando focado com erro.
          ),
          filled: true, // Preenche o campo de texto.
          fillColor: Colors.pink.withOpacity(0.08), // Cor de preenchimento do campo de texto.
          contentPadding: const EdgeInsets.symmetric(vertical: 18.0, horizontal: 16.0), // Preenchimento do conteúdo.
          labelStyle: TextStyle(color: Colors.grey[700]), // Estilo do rótulo.
          hintStyle: TextStyle(color: Colors.grey[400]), // Estilo do texto de dica.
          prefixIconColor: Colors.pinkAccent, // Cor do ícone de prefixo.
          errorStyle: const TextStyle(color: Colors.pink, fontSize: 14), // Estilo do texto de erro.
        ),
        textTheme: const TextTheme(
          headlineMedium: TextStyle(color: Colors.black87), // Estilo para headlineMedium.
          headlineSmall: TextStyle(color: Colors.black87), // Estilo para headlineSmall.
          titleMedium: TextStyle(color: Colors.black54), // Estilo para titleMedium.
          titleSmall: TextStyle(color: Colors.black87), // Estilo para titleSmall.
          titleLarge: TextStyle(color: Colors.black87), // Estilo para titleLarge.
          bodyMedium: TextStyle(color: Colors.black54), // Estilo para bodyMedium.
        ),
      ),
      home: const AuthChecker(), // Define AuthChecker como a tela inicial.
    );
  }
}

/// Função principal que inicia a aplicação Flutter.
void main() {
  runApp(
    const ProviderScope(
      child: MyApp(), // Envolve MyApp com ProviderScope para habilitar o Riverpod.
    ),
  );
}
